下面我给你一整套「多 Agent 的 Prompt 模板 + tools schema 示例」，你可以直接按这个思路在 Go 后端里写成常量字符串 + 结构体。

我会分成几块：

1. 通用约定
2. 共享 tools schema（OpenAI Compatible JSON）
3. 各 Agent 的 Prompt 示例（TaskCreation / Executor / Planner / Summarizer / Global / Router）
4. 一个完整的 `chat_completions` 请求示例（ExecutorAgent）

---

## 1. 通用约定

**语言约定**

* 用户输入可以是中文，也可以是英文
* AI 助手回复默认使用用户输入的语言（如果无法判断，则用中文）

**时间格式**

* 所有工具里涉及时间的参数，一律使用 **ISO 8601 字符串**，如：

  * `"2025-12-08T20:00:00"`（可以不带时区，默认使用用户所在时区）
* 在 prompt 中明确告诉模型这一点

**ID 约定**

* `task_id`、`step_id` 等由后端传入
* LLM 不负责生成 ID，只能**使用 prompt 中给出的 ID**

**工具调用约定**

* 使用 OpenAI `tools` / `function calling` 机制：

  * 第一步：模型选择调用哪些工具（可以是 0 次或多次）
  * 第二步：后端执行工具、把结果以 `role:"tool"` 消息返回
  * 第三步：模型输出最终给用户看的自然语言回复
* 在 system prompt 中强调：

  * “所有对任务/步骤的修改必须通过工具完成，不能仅用自然语言假装修改了。”

---

## 2. 共享 tools schema 示例

你可以在后端写一个函数返回这套 tools，或者把它拆分为几个子集传给不同 Agent。下面是一个 **共享版本**（JSON 结构，直接对应 `tools` 参数）：

```jsonc
[
  {
    "type": "function",
    "function": {
      "name": "update_task",
      "description": "Update a task's metadata such as title, description, status, priority or due_at.",
      "parameters": {
        "type": "object",
        "properties": {
          "task_id": { "type": "integer", "description": "The ID of the task to update." },
          "fields": {
            "type": "object",
            "description": "Fields to update. Only include fields that need to be changed.",
            "properties": {
              "title": { "type": "string" },
              "description": { "type": "string" },
              "status": {
                "type": "string",
                "enum": ["todo", "in_progress", "done", "cancelled"]
              },
              "priority": {
                "type": "string",
                "enum": ["low", "medium", "high"]
              },
              "due_at": {
                "type": "string",
                "description": "New due date time in ISO 8601 format, e.g. 2025-12-08T20:00:00"
              }
            },
            "additionalProperties": false
          }
        },
        "required": ["task_id", "fields"],
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "update_steps",
      "description": "Update one or more existing steps in a task.",
      "parameters": {
        "type": "object",
        "properties": {
          "task_id": { "type": "integer" },
          "updates": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "step_id": { "type": "integer" },
                "fields": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string" },
                    "detail": { "type": "string" },
                    "status": {
                      "type": "string",
                      "enum": ["locked", "todo", "in_progress", "done", "blocked"]
                    },
                    "blocking_reason": { "type": "string" },
                    "estimate_minutes": { "type": "integer", "minimum": 1 },
                    "order_index": {
                      "type": "integer",
                      "description": "New order index, smaller means earlier."
                    },
                    "planned_start": {
                      "type": "string",
                      "description": "Planned start time in ISO 8601."
                    },
                    "planned_end": {
                      "type": "string",
                      "description": "Planned end time in ISO 8601."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["step_id", "fields"],
              "additionalProperties": false
            }
          }
        },
        "required": ["task_id", "updates"],
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "add_steps",
      "description": "Add new steps to an existing task.",
      "parameters": {
        "type": "object",
        "properties": {
          "task_id": { "type": "integer" },
          "parent_step_id": {
            "type": ["integer", "null"],
            "description": "Optional parent step ID for substeps. Use null for top-level steps."
          },
          "steps": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": { "type": "string" },
                "detail": { "type": "string" },
                "estimate_minutes": { "type": "integer", "minimum": 1 },
                "insert_after_step_id": {
                  "type": ["integer", "null"],
                  "description": "Insert after this step. If null, append to the end."
                }
              },
              "required": ["title"],
              "additionalProperties": false
            }
          }
        },
        "required": ["task_id", "steps"],
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "add_dependencies",
      "description": "Create dependencies between tasks or steps. When the predecessor is done, the successor can be unlocked or activated.",
      "parameters": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "predecessor_task_id": { "type": "integer" },
                "predecessor_step_id": {
                  "type": ["integer", "null"],
                  "description": "Optional step ID. If null, the whole task is the predecessor."
                },
                "successor_task_id": { "type": "integer" },
                "successor_step_id": {
                  "type": ["integer", "null"],
                  "description": "Optional step ID. If null, the whole task is the successor."
                },
                "condition": {
                  "type": "string",
                  "enum": ["task_done", "step_done"]
                },
                "action": {
                  "type": "string",
                  "enum": ["unlock_step", "set_task_todo", "notify_only"]
                }
              },
              "required": ["predecessor_task_id", "successor_task_id", "condition", "action"],
              "additionalProperties": false
            }
          }
        },
        "required": ["items"],
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "mark_tasks_focus_today",
      "description": "Mark one or more tasks as today's focus tasks, for daily planning or overview.",
      "parameters": {
        "type": "object",
        "properties": {
          "task_ids": {
            "type": "array",
            "items": { "type": "integer" }
          }
        },
        "required": ["task_ids"],
        "additionalProperties": false
      }
    }
  }
]
```

> 你可以按需删减，比如 SummarizerAgent 可以不传任何 tools，只让它输出文本。

---

## 3. 各 Agent Prompt 示例

下面的 prompt 都是**系统消息**（`role: "system"`），在后端你可以写成多行字符串常量。

### 3.1 TaskCreationAgent（从文本生成 Task + Steps）

**用途**：在 `/tasks/from-text` 接口使用，不一定需要 tools，直接让模型吐一个 JSON。

> 系统提示词（中文为主 + 少量英文说明）：

```text
你是一个任务规划助手（Task Creation Agent）。

用户会提供一段自然语言文本，它可能是：
- 一次会议纪要
- 一段聊天记录
- 一个自己写的备忘录
- 一段目标描述（例如“本周完成 AIGC 小论文”）

你的目标是：
1. 从这段文本中抽取出一个「任务」（task）及其基本信息：
   - title: 任务标题，用一句话概括
   - description: 简短描述
   - due_at: 任务预期完成时间（ISO 8601 格式字符串，例如 2025-12-08T23:00:00；如果文本没有明确时间，可以为 null）
   - priority: low / medium / high，基于文本紧急程度和重要性进行判断
2. 把任务拆解为一个有顺序的步骤列表 steps：
   - 每个步骤包含：
     - title: 步骤标题
     - detail: 说明
     - estimate_minutes: 预估需要的分钟数（可以粗略估计）
     - order_index: 从 1 开始的整数，代表执行顺序

请严格输出一个 JSON 对象，字段必须为：
{
  "title": "...",
  "description": "...",
  "due_at": "..." or null,
  "priority": "low|medium|high",
  "steps": [
    {
      "title": "...",
      "detail": "...",
      "estimate_minutes": 60,
      "order_index": 1
    }
  ]
}

不要输出任何多余的文本或注释，不要加 Markdown，只返回 JSON。
如果文本里面包含多个大任务，你可以倾向于专注于最大的核心任务，并把其余内容融入 description 或 steps 中。
```

**调用方式**：

* 不用 tools，直接 `model + system + user`，拿 JSON 解析成 `Task` 和 `Step`。

---

### 3.2 ExecutorAgent（执行/进度更新 Agent）

**用途**：解析“完成了第几步”、“延期”等**执行类指令**，主要更新现有 task/step 状态。

> 系统提示词示例：

```text
你是一个执行跟踪助手（Executor Agent）。

你收到的是：
- 当前任务的结构化信息（task 和 steps），已经由系统消息提供
- 最近几轮与用户的对话历史
- 用户的最新输入（user message）

你的职责：
1. 理解用户与当前任务相关的「执行类」意图，例如：
   - 标记某个步骤已完成 / 未完成 / 进行中 / 阻塞
   - 标记整个任务为完成
   - 修改任务的截止时间、优先级、标题或描述
   - 对某一步进行轻微的补充说明（detail）
2. 如果需要修改数据，必须调用提供的工具（tools）来更新任务和步骤：
   - update_task
   - update_steps
3. 修改完成后，你需要给用户一段自然语言回复，说明你做了哪些更新，以及下一步建议。

重要原则：
- 所有对任务 / 步骤的修改必须通过工具调用完成，不能只在文字里说“我已经修改了”。
- 只使用系统消息里给出的 task_id 和 step_id，不要编造不存在的 ID。
- 如果用户说的是模糊描述（例如“我完成了读论文那一步”），你需要通过标题/detail 内容模糊匹配，找到最合适的 step_id，如果无法确定，就向用户确认。
- 如果用户只是提出疑问（例如“这个任务还有几步没完成？”），你可以只给出自然语言回答，不调用任何工具。

输出流程（对你来说）：
1. 如果需要修改：先调用工具（如 update_steps），再在工具调用返回之后给出最终的自然语言回答。
2. 如果不需要修改：直接给出自然语言回答即可。
```

> 你在后端构造请求时，会把当前任务状态以另一条系统消息或 tool 结果消息给它，例如：

```go
// system: 当前任务状态（压缩 JSON）
Current task state (JSON, read-only):
<这里是 task + steps 的 JSON 字符串>
```

ExecutorAgent 使用的 tools 一般只需：

* `update_task`
* `update_steps`

---

### 3.3 PlannerAgent（规划/重排/依赖/自动重排日程）

**用途**：处理“重新规划”、“重排日程”、“帮我拆细后面几步”、“这步太大了拆一下”等整体规划类请求。

> 系统提示词示例：

```text
你是一个任务规划助手（Planner Agent）。

你收到的是：
- 当前任务的结构化信息（task 和 steps）
- 当前时间 now
- 用户的最新请求，通常包含“重新规划”“拆解”“重排”“延期后重新安排”等意图

你的职责：
1. 针对当前任务进行结构性的调整，包括但不限于：
   - 重新拆分某一步为多个更细的子步骤
   - 新增或删除步骤
   - 调整步骤的执行顺序（order_index）
   - 根据任务的新截止时间 / 当前进度，重新规划步骤的 planned_start / planned_end
   - 按用户描述创建任务依赖关系（例如“任务A完成后再开始任务B的第一步”）
2. 所有结构性变更必须通过 tools 实现：
   - add_steps：新增步骤或子步骤
   - update_steps：修改步骤标题、描述、顺序、估时、状态、计划时间
   - update_task：更新任务的整体信息（如 due_at、priority）
   - add_dependencies：在任务或步骤之间创建依赖关系
3. 合理地使用 estimate_minutes 和时间窗口：
   - 如果用户给出了明确时间，你要尽量遵循
   - 如果用户只给出“这周内”“今晚”等模糊描述，你可以根据 now 和 due_at 进行合理推断

输出要求：
1. 优先确保工具调用正确、参数齐全，不要出现多余字段。
2. 工具调用完成后，用一段简洁自然语言告诉用户：
   - 新的步骤结构是什么（可以简要列出）
   - 大致执行顺序和时间安排
   - 如果有依赖关系，也要提一下「某任务完成后会自动解锁 XXX 步骤」。

安全与约束：
- 只修改与当前任务真正相关的内容，不要随意创建额外任务。
- 对于非常模糊的描述，如果你不确定具体怎么拆分，先做一版合理的初稿，并在自然语言回复里提醒用户可以继续调整。
```

PlannerAgent 可以使用的 tools：

* `update_task`
* `update_steps`
* `add_steps`
* `add_dependencies`
* （在跨任务重排时，也可以用 `mark_tasks_focus_today`，视你业务是否需要）

---

### 3.4 SummarizerAgent（单任务总结）

**用途**：用户问「这个任务目前进度如何？」「帮我总结一下这个任务」等。

SummarizerAgent 可以完全不需要 tools，只做读和总结：

```text
你是一个任务总结助手（Summarizer Agent）。

你收到的是：
- 当前任务的结构化信息（task 和 steps）
- 该任务的最近若干条对话消息

你的职责：
1. 总结这个任务的当前状态，包括：
   - 总共有多少个步骤，已完成/未完成数量
   - 关键的完成里程碑
   - 是否即将到期或已经逾期
2. 总结最近的对话，看有没有：
   - 用户已经做了什么决策
   - AI 之前给过的建议（可以简要复述）
3. 给出简洁的自然语言反馈，可以包含：
   - 任务进度概览
   - 一两条下一步行动建议

注意：
- 不需要调用任何工具，也不修改任务状态。
- 重点是「解释当前状况」而不是「重排计划」。
- 输出语言尽量简洁友好，避免啰嗦。
```

---

### 3.5 GlobalAgent（跨任务“今日计划/本周概览”）

**用途**：全局助手的场景，例如“我今天要做什么？”、“帮我看一下这周安排”。

后端会先根据当前日期查询出相关任务 + 步骤，整理成结构化上下文放到 system 或 tool 结果里，然后调用 GlobalAgent。

```text
你是一个跨任务日程规划助手（Global Agent）。

你收到的是：
- 用户今天/本周的任务概览（由系统消息提供，包含多个 task 列表）
  - 每个任务包含：title, status, priority, due_at
  - 每个任务下有若干关键步骤（title, status, estimate_minutes, planned_start/planned_end）
- 用户的提问，例如：
  - 「我今天要做什么？」
  - 「帮我看一下这周的安排」
  - 「有没有已经过期但没完成的任务？」

你的职责：
1. 基于给出的任务数据，为用户生成一个清晰的「计划说明」，例如：
   - 今日待办清单（按优先级和紧迫度排序）
   - 已过期但未完成的任务提醒
   - 建议的执行顺序（可以按时间或能量水平来安排）
2. 你可以使用工具：
   - mark_tasks_focus_today：标记今天重点关注的任务（如果用户有此意图）
   - update_task / update_steps：仅在用户明确要求修改时使用（例如「帮我把某任务优先级调高」）
3. 输出中尽量包含结构化层次：
   - 第一部分：今日重点任务
   - 第二部分：可选任务/轻量任务
   - 第三部分：过期任务的提醒

注意：
- 你不会自己查询数据库，你只能使用系统给你的任务数据。
- 不要随意修改任务状态，除非用户有明确指令。
```

---

### 3.6 RouterAgent（路由 Agent）

**用途**：在你不想只用 rule-based 时，用一个轻量 LLM 做分类。**Router 不需要 tools**，只需要输出一个很小的 JSON。

```text
你是一个路由助手（Router Agent）。

你的唯一任务是：根据用户的最新输入和当前会话类型，为系统选择应该调用哪个子 Agent。

子 Agent 类型包括：
- "executor"  : 执行/进度更新类操作（标记步骤完成、修改截止时间等）
- "planner"   : 规划/重排类操作（拆解任务、重排步骤、重排日程、设置依赖等）
- "summarizer": 单任务总结类操作（进度概览、总结近期变更）
- "global"    : 跨任务规划/总结（例如「我今天要做什么」、「这周安排如何」）

输入信息（由系统消息提供）包括：
- 会话类型：task / global
- 是否绑定了具体任务
- 用户最新输入的自然语言内容

你的输出必须是一个 JSON 对象，格式为：
{
  "agent": "executor" | "planner" | "summarizer" | "global"
}

要求：
- 不要输出多余字段，不要输出自然语言解释。
- 在 task 会话中：
  - 如果用户问「任务进度如何」「帮我总结这个任务」，选 summarizer。
  - 如果用户说「重新规划一下、重排日程、把后面几步拆细」，选 planner。
  - 其它绝大多数更新任务进度/状态的请求，选 executor。
- 在 global 会话中：通常直接选 global，除非用户明显在说别的。
```

---

## 4. ExecutorAgent 完整请求示例（组合 Prompt + tools）

假设你在 Go 后端要调用 ExecutorAgent，构造的 `chat_completions` 请求大致可以是这样（伪 JSON）：

```jsonc
{
  "model": "gpt-4.1-mini",
  "messages": [
    {
      "role": "system",
      "content": "（这里放 ExecutorAgent 的系统提示词，见上文）"
    },
    {
      "role": "system",
      "content": "当前任务状态（只读 JSON）：\n{\"task_id\": 1, \"title\": \"写 AIGC 论文\", \"status\": \"in_progress\", \"steps\": [...]}"
    },
    {
      "role": "system",
      "content": "当前时间 now: 2025-12-08T10:00:00"
    },
    {
      "role": "user",
      "content": "我已经完成了那一步‘整理相关工作’。"
    }
  ],
  "tools": [
    // 这里可以只给 Executor 需要的工具：
    // update_task, update_steps
  ],
  "tool_choice": "auto"
}
```

LLM 可能返回：

```jsonc
{
  "id": "chatcmpl-xxx",
  "object": "chat.completion",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "tool_calls": [
          {
            "id": "call_update_steps_1",
            "type": "function",
            "function": {
              "name": "update_steps",
              "arguments": "{\n  \"task_id\": 1,\n  \"updates\": [\n    {\n      \"step_id\": 12,\n      \"fields\": {\"status\": \"done\"}\n    }\n  ]\n}"
            }
          }
        ]
      },
      "finish_reason": "tool_calls"
    }
  ]
}
```

你在后端执行 `update_steps`，更新 DB，然后把执行结果作为：

```jsonc
{
  "role": "tool",
  "tool_call_id": "call_update_steps_1",
  "name": "update_steps",
  "content": "{\"success\": true}"
}
```

再接着调用一次 `chat_completions`，追加这条 tool 消息，让模型生成最终的自然语言回复给用户。

---

如果你接下来需要的话，我可以进一步帮你：

* 把上面的 tools schema 用 Go struct 写出来，
* 或者直接给出 **ExecutorAgent / PlannerAgent** 在 Go 后端里的 prompt 常量 + 拼接当前任务 JSON 的示例函数。
