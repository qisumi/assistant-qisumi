下面是一份“从零到完整”的设计文档，把之前聊过的基础功能 + 进阶功能全都合并进去，并统一成一套方案。你可以直接当项目设计文档用，然后按模块开始实现。

---

# 1. 项目简介

## 1.1 产品定位

一个基于 AI 的**任务规划 & 备忘录系统**，特点：

* 用户只需要**粘贴一段自然语言文本**（会议纪要、聊天记录、备忘录等），系统自动：

  * 生成任务（标题、描述、截止时间、优先级）
  * 拆解分步骤 TODO（可含子步骤、预计耗时、顺序）
* 每个任务对应一个**独立对话会话**：

  * 用户用自然语言更新进度：

    > “我已经完成了查文献这一步”
    > “帮我把截止时间改到下周五”
  * AI Agent 分析后，自动更新底层任务结构、步骤状态、任务依赖、日程等。
* 支持**多设备多账号同步**，用户可在任何设备上登录查看与更新。
* 支持**多 Agent 协作**：

  * `Planner`：拆解 / 重排 / 规划
  * `Executor`：进度更新、简单修改
  * `Summarizer`：单任务总结
  * `Global`：跨任务总结（如“我今天要做什么？”）
  * `Router`：根据用户输入自动选择合适的 Agent

## 1.2 目标用户与约束

* 使用者 ≤ 10 人，多为开发者/研究者自用
* 部署环境：单台服务器，2 核 CPU，2G 内存，已跑其他轻量服务
* LLM 计算全部在**外部 OpenAI-Compatible 服务**完成，本服务只做业务逻辑与 orchestrator

---

# 2. 功能需求

## 2.1 基础功能

1. **账号系统 + 多设备同步**

   * 用户注册/登录（邮箱 + 密码）
   * JWT 认证
   * 所有任务/对话与 `user_id` 关联，登录后可在不同设备看到同一账号的数据

2. **用户 LLM 配置**

   * 每个账号可以配置：

     * `base_url`（OpenAI Compatible 接口地址）
     * `api_key`
     * 默认 `model`
   * 后端加密存储 `api_key`，调用时解密使用

3. **任务创建（从一段文本）**

   * 用户粘贴原始文本
   * 调用 LLM 抽取：

     * 任务标题/描述
     * 截止时间/优先级/标签（可选）
     * 拆解步骤：名称、描述、预计时长、顺序
   * 写入数据库，自动创建一个与任务绑定的「任务会话 session」

4. **任务管理**

   * 查看任务列表（按截止时间、状态、优先级）
   * 查看任务详情（任务信息 + 步骤列表）
   * 手工修改：任务标题/描述/截止时间/优先级
   * 手工增删/重排步骤，勾选完成状态

5. **任务会话（Chat）**

   * 每个任务有独立对话窗口
   * 用户自然语言更新任务：

     * “完成了第 2 步”
     * “把这个任务延期到下周三”
     * “帮我把剩下的步骤拆细一点”
   * AI Agent：

     * 返回自然语言回复
     * 同时返回结构化“任务更新 patch”，更新数据库

## 2.2 进阶功能

6. **多任务依赖**

   * 支持配置“前置任务/步骤 → 后置任务/步骤”的依赖关系
   * 前置完成时：

     * 自动解锁后置任务的某个步骤（从 `locked` 变为 `todo`）
     * 或自动把后置任务状态从 `todo` 改为 `in_progress`
     * 或仅发送提醒/系统消息

7. **自动重排日程**

   * 每个步骤可以有计划起止时间：`planned_start` / `planned_end` / `estimate_minutes`
   * 当任务延期/过期/进度落后时：

     * 由 `PlannerAgent` 计算 + LLM 规划：给出新的执行顺序和时间
     * 更新步骤的计划时间和顺序
     * 用自然语言向用户说明新的计划

8. **跨任务总结**

   * 用户问：“我今天要做什么？”、“这周的工作安排是什么？”
   * 后端根据当前日期查询所有相关任务和步骤，构造结构化上下文
   * `GlobalAgent` 基于上下文生成：

     * 今日计划摘要
     * 建议执行顺序
     * 逾期任务提醒

9. **多 Agent 模式 + Router Agent**

   * 多个专职 Agent：

     * `TaskCreationAgent`：从文本创建任务（可视为 `Planner` 的一个场景）
     * `PlannerAgent`：拆解、重排、依赖、重排日程
     * `ExecutorAgent`：进度更新、简单修改
     * `SummarizerAgent`：单任务总结
     * `GlobalAgent`：跨任务总结/今日计划
   * `RouterAgent`：

     * 根据会话类型（任务/全局）、用户输入、上下文，选择一个子 Agent 处理
     * 优先使用 rule-based 规则；不确定时调用一个轻量的 LLM 路由器

---

# 3. 技术选型

* **后端**：Go（Gin/Echo/Fiber 均可）
* **前端**：React + TypeScript + PWA（Vite 构建）
* **数据库**：MySQL（InnoDB、utf8mb4）
* **认证**：JWT（HTTP header: `Authorization: Bearer <token>`）
* **LLM**：OpenAI Compatible API（例如 `/v1/chat/completions`）
* **部署**：

  * 单个 Go 可执行程序 + MySQL 实例
  * 前端打包为静态资源，由 Nginx/Caddy 提供

---

# 4. 核心领域模型

## 4.1 概念

* **User**：用户账号
* **LLMConfig**：每个用户的模型配置（base_url, api_key, model）
* **Task**：任务（有状态、截止时间、优先级）
* **TaskStep**：任务步骤（可带依赖关系、计划起止时间）
* **TaskDependency**：任务/步骤间的依赖
* **Session**：

  * 任务会话：针对单个任务的对话
  * 全局会话：跨任务的助手对话
* **Message**：会话中的一条消息（记录 sender role、agent_name、内容）
* **Agent**：逻辑角色，负责不同类型请求
* **Router**：根据输入选择具体 Agent

---

# 5. 数据库设计（MySQL）

只给关键表，并省略一些非关键字段/索引（可按需扩展）。

## 5.1 用户与 LLM 配置

```sql
CREATE TABLE users (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  display_name VARCHAR(255),
  password_hash VARCHAR(255) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE user_llm_settings (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED NOT NULL,
  base_url VARCHAR(512) NOT NULL,
  api_key_enc TEXT NOT NULL,
  model VARCHAR(255) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  CONSTRAINT fk_llm_user FOREIGN KEY (user_id) REFERENCES users(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 5.2 任务 & 步骤

```sql
CREATE TABLE tasks (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  status ENUM('todo','in_progress','done','cancelled') NOT NULL DEFAULT 'todo',
  priority ENUM('low','medium','high') DEFAULT 'medium',
  due_at DATETIME NULL,
  created_from TEXT,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  CONSTRAINT fk_tasks_user FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_tasks_user (user_id),
  INDEX idx_tasks_user_status (user_id, status),
  INDEX idx_tasks_user_due (user_id, due_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE task_steps (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  task_id BIGINT UNSIGNED NOT NULL,
  order_index INT NOT NULL DEFAULT 0,
  title VARCHAR(255) NOT NULL,
  detail TEXT,
  status ENUM('locked','todo','in_progress','done','blocked') NOT NULL DEFAULT 'todo',
  blocking_reason TEXT,
  estimate_minutes INT NULL,
  planned_start DATETIME NULL,
  planned_end   DATETIME NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  CONSTRAINT fk_steps_task FOREIGN KEY (task_id) REFERENCES tasks(id),
  INDEX idx_steps_task (task_id),
  INDEX idx_steps_task_order (task_id, order_index),
  INDEX idx_steps_schedule (task_id, planned_start, planned_end)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 5.3 任务依赖

```sql
CREATE TABLE task_dependencies (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,

  predecessor_task_id BIGINT UNSIGNED NOT NULL,
  predecessor_step_id BIGINT UNSIGNED NULL,

  successor_task_id   BIGINT UNSIGNED NOT NULL,
  successor_step_id   BIGINT UNSIGNED NULL,

  condition ENUM('task_done','step_done') NOT NULL,
  action ENUM('unlock_step','set_task_todo','notify_only') NOT NULL DEFAULT 'unlock_step',

  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT fk_dep_pre_task FOREIGN KEY (predecessor_task_id) REFERENCES tasks(id),
  CONSTRAINT fk_dep_pre_step FOREIGN KEY (predecessor_step_id) REFERENCES task_steps(id),
  CONSTRAINT fk_dep_suc_task FOREIGN KEY (successor_task_id) REFERENCES tasks(id),
  CONSTRAINT fk_dep_suc_step FOREIGN KEY (successor_step_id) REFERENCES task_steps(id),

  INDEX idx_dep_pre (predecessor_task_id, predecessor_step_id),
  INDEX idx_dep_suc (successor_task_id, successor_step_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 5.4 会话 & 消息

```sql
CREATE TABLE sessions (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED NOT NULL,
  task_id BIGINT UNSIGNED NULL,
  type ENUM('task','global') NOT NULL DEFAULT 'task',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_sessions_user FOREIGN KEY (user_id) REFERENCES users(id),
  CONSTRAINT fk_sessions_task FOREIGN KEY (task_id) REFERENCES tasks(id),
  INDEX idx_sessions_user (user_id),
  INDEX idx_sessions_task (task_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE messages (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  session_id BIGINT UNSIGNED NOT NULL,
  role ENUM('user','assistant','system') NOT NULL,
  agent_name VARCHAR(64) NULL,
  content TEXT NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_messages_session FOREIGN KEY (session_id) REFERENCES sessions(id),
  INDEX idx_messages_session (session_id, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

---

# 6. 后端设计

## 6.1 模块划分

```text
/internal
  /auth          // 注册登录、JWT
  /config        // 配置（DB、密钥、端口）
  /db            // MySQL 初始化与连接池
  /llm           // OpenAI-Compatible 客户端
  /task
      task_repo.go
      step_repo.go
      dependency_repo.go
      task_service.go
  /session
      session_repo.go
      message_repo.go
  /agent
      router.go          // RouterAgent
      planner_agent.go
      executor_agent.go
      summarizer_agent.go
      global_agent.go
      agent_service.go   // 统一入口
  /http
      auth_handler.go
      task_handler.go
      session_handler.go
      settings_handler.go
```

## 6.2 LLM 客户端（OpenAI Compatible）

```go
type ChatMessage struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

type ChatRequest struct {
    Model    string        `json:"model"`
    Messages []ChatMessage `json:"messages"`
    Tools    []any         `json:"tools,omitempty"`
    ToolChoice any         `json:"tool_choice,omitempty"`
    // 其他参数: temperature, max_tokens...
}

type ChatResponse struct {
    // 根据 OpenAI compatible 结构定义
}
```

用户的 `api_key / base_url / model` 由 `user_llm_settings` 提供。

## 6.3 Agent 抽象

```go
type AgentRequest struct {
    UserID    uint64
    SessionID uint64
    TaskID    *uint64
    UserInput string

    Task      *Task        // 任务会话时非空
    Messages  []Message    // 最近对话
    Now       time.Time

    LLMConfig LLMConfig
}

type TaskPatch struct {
    Type    string          // "UpdateStepStatus" / "RescheduleStep" / ...
    Payload map[string]any
}

type AgentResponse struct {
    AssistantMessage string
    TaskPatches      []TaskPatch
}

type Agent interface {
    Name() string
    Handle(ctx context.Context, req AgentRequest) (*AgentResponse, error)
}
```

`AgentService` 在处理用户消息时：

1. 加载 `Session/Task/History/LLMConfig`
2. 调用 Router 决定 `agentName`
3. 找到对应 Agent 实例执行 `Handle`
4. 根据 `TaskPatches` 更新数据库（事务）
5. 写入 `messages`（记录 `agent_name`）
6. 返回响应给 HTTP handler → 前端

## 6.4 Router 设计

### 6.4.1 rule-based + LLM fallback

```go
type Router interface {
    Route(req AgentRequest) string // 返回 agent 名称: "executor" / "planner" / ...
}
```

规则示意：

* 如果 `Session.type == "global"` → `GlobalAgent`
* 如果包含关键词：

  * “总结”“overview”“回顾”“progress” → `SummarizerAgent`
  * “重新规划”“重排”“replan”“reschedule”“重排日程” → `PlannerAgent`
  * “今天要做什么”“today” & global → `GlobalAgent`
* 其它 → `ExecutorAgent`

如果规则没有匹配（或你想更智能一点），再调用 LLM Router：

* system：你是 Router，只输出 `{"agent": "executor|planner|summarizer|global"}` 的 JSON
* user：用户输入 + 会话类型 + 是否绑定任务
* 最终根据该 JSON 决定 Agent

---

# 7. 关键业务流程

## 7.1 从文本创建任务

1. 前端：

   * 用户粘贴文本，点击「生成任务」
   * POST `/api/tasks/from-text`
2. 后端：

   1. 验证 JWT，识别 `user_id`
   2. 从 `user_llm_settings` 取 LLM 配置
   3. 调用 `TaskCreationAgent`（可以是 `PlannerAgent` 的一个模式）：

      * system：说明需输出结构化 JSON: title, description, due_at, priority, steps[]
      * user：原始文本
   4. 解析 JSON，写入：

      * `tasks`（含 `created_from`）
      * `task_steps`
   5. 创建一个 `sessions` 记录（type='task'，task_id 指向新任务）
   6. 写一条初始 assistant 消息：对任务的总结和步骤展示
   7. 返回 `task` + `steps` + 首条消息

## 7.2 任务会话中更新状态

1. 前端：

   * 在任务详情页，对话框输入文本
   * POST `/api/sessions/:sessionId/messages`（task session）
2. 后端：

   1. 验证用户 & session 权限
   2. 写入一条 user 消息
   3. 查询 session 对应 `task`，以及最近 N 条消息
   4. 构造 `AgentRequest`，交给 `AgentService.HandleUserMessage`
   5. 由 Router 选择 Agent（通常是 `ExecutorAgent`）
   6. ExecutorAgent 内部：

      * 使用 LLM + tools/function calling：

        * `update_step_status`
        * `update_task_metadata`（截止时间等）
        * `add_steps` / `delete_steps`
        * `add_dependency`（如用户表达依赖关系）
      * 返回 `AssistantMessage` + `TaskPatches`
   7. `AgentService.applyTaskPatches`：

      * 在 DB 中应用所有 patch（事务）
      * 如果某步/任务状态变成 done → 调 `DependencyService` 解锁后续任务/步骤
   8. 写入一条 assistant 消息，`agent_name` = `executor`
   9. 返回最新任务状态 + assistant 消息给前端

## 7.3 多任务依赖 & 自动解锁

当：

* 某任务状态从非 done → done，或
* 某步骤状态从非 done → done

`TaskService` 在更新状态后调用：

```go
DependencyService.OnTaskOrStepDone(preTaskID, preStepID)
```

该服务：

1. 在 `task_dependencies` 中查出所有：

   * `predecessor_task_id = preTaskID`
   * `predecessor_step_id = preStepID`（或 NULL, 视 condition 而定）
2. 对每条依赖，根据 `action`：

   * `unlock_step`：将 `successor_step.status` 从 `locked` → `todo`
   * `set_task_todo`：将 `successor_task.status` 置为 `todo`
   * `notify_only`：写一条系统消息/提醒
3. 可选：在后置任务的 session 中写一条系统消息，提示已自动解锁或激活。

## 7.4 自动重排日程

触发方式：

* 用户自然语言说“延期”“重排计划”等 → Router 选择 `PlannerAgent`

`PlannerAgent` 流程：

1. 由业务逻辑先更新基本字段（例如修改 `tasks.due_at`）
2. PlannerAgent 获取：

   * 当前任务或一组任务的未完成步骤（包含 `estimate_minutes`、当前计划时间、截止时间）
   * 当前时间 `Now`
3. 构造 LLM 请求：

   * system：你是日程规划助手；需在给定时间约束内重排步骤执行顺序和时间；输出 JSON。
   * user：用户请求原文
   * context：任务信息（结构化）
4. LLM 输出：

   ```json
   {
     "replan_steps": [
       {
         "step_id": 101,
         "planned_start": "2025-12-09T20:00:00",
         "planned_end": "2025-12-09T22:00:00"
       },
       ...
     ]
   }
   ```
5. PlannerAgent 将其转为 `TaskPatches`：

   * `Type="RescheduleStep"`，payload 包含 `step_id` & 新时间
6. `AgentService.applyTaskPatches` 批量更新 DB
7. 返回自然语言说明新的计划

## 7.5 跨任务总结（“我今天要做什么？”）

1. 前端：

   * 用户在「全局助手」页面输入：“我今天要做什么？”
   * 若不存在 global session，则 POST `/api/sessions` 创建 `type='global'`
   * 然后 POST `/api/sessions/:id/messages`
2. 后端：

   1. Session 类型为 `global` → Router 直接选 `GlobalAgent`
   2. `GlobalAgent`：

      * 查询：

        * 今天 `due_at` 在今天的任务
        * 未来两天内 due 且优先级高的任务
        * 已过期且未完成任务（提醒用）
      * 构造结构化上下文（只传必要字段，控制 token）
      * 调用 LLM 生成：

        * 今日计划自然语言描述
        * 建议执行顺序（可选 JSON）
   3. 写 assistant 消息，`agent_name="global"`
   4. 返回给前端

---

# 8. 前端设计（React + PWA）

## 8.1 页面结构

* `/login`：登录/注册
* `/settings`：用户资料 & LLM 配置
* `/tasks`：任务列表
* `/tasks/:id`：任务详情 + 会话
* `/global-assistant`：全局助手（今日计划/周计划）
* `/create-from-text`：从文本创建任务

## 8.2 状态与存储

* 全局状态管理（Zustand / Redux）：

  * 当前用户信息
  * JWT token
  * 当前 LLM 配置是否已设置（从后端加载）
* PWA：

  * `manifest.json`：name、short_name、图标、start_url、display=standalone
  * `service worker`：

    * 缓存静态资源
    * 简单的 offline fallback：无网络时至少能打开 UI（可提示“当前离线，无法同步数据”）

---

# 9. 性能与资源考虑（2C / 2G）

* **MySQL 连接池**：

  * Go 侧：`SetMaxOpenConns(5)` / `SetMaxIdleConns(5)` 即可
* **LLM 调用**：

  * 主耗时在外部服务，后端只做轻量处理
  * Router 优先 rule-based，只有少数模糊场景才调 LLM Router
* **Agent 设计**：

  * 每次用户消息只调用**一个** Agent（一次 LLM 主调用），避免多 Agent 串联
* **定时任务**：

  * 提醒/每日重排可先用 crontab + 调 HTTP endpoint 实现
  * 不需要在 Go 内写复杂 scheduler

---

# 10. 实施里程碑建议

1. **MVP**

   * 用户注册/登录（JWT）
   * Task & Step CRUD（无 AI）
   * 任务列表/详情 + React PWA 外壳

2. **接入 LLM：任务创建**

   * `user_llm_settings` + 配置页
   * `TaskCreationAgent`：从文本创建任务
   * 前端“从文本创建任务”页面

3. **任务会话 + ExecutorAgent**

   * `sessions`/`messages`
   * `/sessions/:id/messages` + `ExecutorAgent`，支持自然语言更新任务和步骤状态

4. **依赖 + 多任务解锁**

   * `task_dependencies`
   * `DependencyService.OnTaskOrStepDone`，后续步骤自动解锁
   * PlannerAgent 支持在对话中配置依赖（可后置）

5. **PlannerAgent + 自动重排日程**

   * 步骤增加 `estimate_minutes` / `planned_start` / `planned_end`
   * 支持“延期”“重排计划”类指令

6. **GlobalAgent + RouterAgent**

   * 全局会话（type='global'）
   * “我今天要做什么？”等查询
   * 引入 Router，优先 rule-based，再考虑 LLM fallback
   * SummarizerAgent：单任务总结