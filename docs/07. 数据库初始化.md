好，我分三块给你：

1. **GORM 初始化 + AutoMigrate**
2. **写系统消息的简单封装（结合依赖的 notify_only 场景）**
3. **前端 React + PWA 架构设计**

下面的包名统一用 `your-module-name/internal/...`，你按自己项目名改一下就行。

---

## 一、GORM 初始化 + AutoMigrate

### 1.1 go.mod 引入 GORM

```go
require (
    gorm.io/gorm v1.25.7 // 示例版本
    gorm.io/driver/mysql v1.5.7
)
```

### 1.2 GORM 初始化（`internal/db/gorm.go`）

```go
package db

import (
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// NewGormDB 初始化 GORM，控制连接池，适配 2C / 2G 小机
func NewGormDB(dsn string) (*gorm.DB, error) {
	cfg := &gorm.Config{
		// 日志级别你可以按需调整
		Logger: logger.Default.LogMode(logger.Warn),
		// 可以开启 PreparedStmt 优化查询
		PrepareStmt: true,
	}

	db, err := gorm.Open(mysql.Open(dsn), cfg)
	if err != nil {
		return nil, err
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	// 小机器：连接池尽量保守
	sqlDB.SetMaxOpenConns(5)
	sqlDB.SetMaxIdleConns(5)
	sqlDB.SetConnMaxLifetime(1 * time.Hour)

	if err := sqlDB.Ping(); err != nil {
		return nil, err
	}

	return db, nil
}
```

### 1.3 GORM 模型（User / LLMSetting / Session / Message）

> Task / TaskStep / TaskDependency 的 GORM 版我们之前已经写过，这里补齐 User / Setting / Session / Message 的 GORM 模型。

#### `internal/auth/models_gorm.go`

```go
package auth

import "time"

type User struct {
	ID           uint64    `gorm:"primaryKey;column:id"`
	Email        string    `gorm:"column:email;type:varchar(255);uniqueIndex;not null"`
	DisplayName  string    `gorm:"column:display_name;type:varchar(255)"`
	PasswordHash string    `gorm:"column:password_hash;type:varchar(255);not null"`
	CreatedAt    time.Time `gorm:"column:created_at;autoCreateTime"`
}

func (User) TableName() string { return "users" }

type UserLLMSetting struct {
	ID        uint64    `gorm:"primaryKey;column:id"`
	UserID    uint64    `gorm:"column:user_id;not null;index"`
	BaseURL   string    `gorm:"column:base_url;type:varchar(512);not null"`
	APIKeyEnc string    `gorm:"column:api_key_enc;type:text;not null"`
	Model     string    `gorm:"column:model;type:varchar(255);not null"`
	CreatedAt time.Time `gorm:"column:created_at;autoCreateTime"`
	UpdatedAt time.Time `gorm:"column:updated_at;autoUpdateTime"`
}

func (UserLLMSetting) TableName() string { return "user_llm_settings" }
```

#### `internal/session/models_gorm.go`

```go
package session

import "time"

type Session struct {
	ID        uint64     `gorm:"primaryKey;column:id"`
	UserID    uint64     `gorm:"column:user_id;not null;index"`
	TaskID    *uint64    `gorm:"column:task_id;index"`
	Type      string     `gorm:"column:type;type:enum('task','global');not null;default:'task'"`
	CreatedAt time.Time  `gorm:"column:created_at;autoCreateTime"`
}

func (Session) TableName() string { return "sessions" }

type Message struct {
	ID        uint64     `gorm:"primaryKey;column:id"`
	SessionID uint64     `gorm:"column:session_id;not null;index"`
	Role      string     `gorm:"column:role;type:enum('user','assistant','system');not null"`
	AgentName *string    `gorm:"column:agent_name;type:varchar(64)"`
	Content   string     `gorm:"column:content;type:text;not null"`
	CreatedAt time.Time  `gorm:"column:created_at;autoCreateTime"`
}

func (Message) TableName() string { return "messages" }
```

> Task / TaskStep / TaskDependency 的模型请用我们之前的 GORM 版本，这里就不再重复。

### 1.4 AutoMigrate（`internal/db/migrate.go`）

```go
package db

import (
	"gorm.io/gorm"

	"your-module-name/internal/auth"
	"your-module-name/internal/dependency"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

// AutoMigrate 执行 GORM 自动迁移
// 一般在 main 启动时调用一次即可。
func AutoMigrate(db *gorm.DB) error {
	return db.AutoMigrate(
		&auth.User{},
		&auth.UserLLMSetting{},
		&task.Task{},
		&task.TaskStep{},
		&dependency.TaskDependency{},
		&session.Session{},
		&session.Message{},
	)
}
```

### 1.5 main 中调用

`cmd/server/main.go` 改成：

```go
package main

import (
	"log"

	"your-module-name/internal/config"
	"your-module-name/internal/db"
	"your-module-name/internal/http"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	gormDB, err := db.NewGormDB(cfg.DatabaseDSN)
	if err != nil {
		log.Fatalf("connect db: %v", err)
	}

	if err := db.AutoMigrate(gormDB); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	r := http.NewRouter(cfg, gormDB)

	if err := r.Run(":" + cfg.HTTPPort); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
```

---

## 二、写系统消息的简单方法

### 2.1 Session 仓库（GORM）

`internal/session/repo_gorm.go`：

```go
package session

import (
	"context"

	"gorm.io/gorm"
)

type Repository struct {
	db *gorm.DB
}

func NewRepository(db *gorm.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) WithTx(tx *gorm.DB) *Repository {
	return &Repository{db: tx}
}

// GetTaskSessionOrCreate: 针对某个 user + task 找到一个 task session，没有就创建。
func (r *Repository) GetTaskSessionOrCreate(ctx context.Context, userID, taskID uint64) (*Session, error) {
	var sess Session
	err := r.db.WithContext(ctx).
		Where("user_id = ? AND task_id = ? AND type = 'task'", userID, taskID).
		First(&sess).Error
	if err == nil {
		return &sess, nil
	}
	if err != gorm.ErrRecordNotFound {
		return nil, err
	}

	sess = Session{
		UserID: userID,
		TaskID: &taskID,
		Type:   "task",
	}
	if err := r.db.WithContext(ctx).Create(&sess).Error; err != nil {
		return nil, err
	}
	return &sess, nil
}

// CreateSystemMessage 在指定 session 中插入 system 消息
func (r *Repository) CreateSystemMessage(ctx context.Context, sessionID uint64, agentName *string, content string) error {
	msg := Message{
		SessionID: sessionID,
		Role:      "system",
		AgentName: agentName,
		Content:   content,
	}
	return r.db.WithContext(ctx).Create(&msg).Error
}

// CreateSystemMessageForTask: 针对某个任务（以及用户）写一条系统消息。
// 用于依赖解锁、系统通知等场景。
func (r *Repository) CreateSystemMessageForTask(
	ctx context.Context,
	userID, taskID uint64,
	content string,
) error {
	sess, err := r.GetTaskSessionOrCreate(ctx, userID, taskID)
	if err != nil {
		return err
	}
	systemAgent := "system"
	return r.CreateSystemMessage(ctx, sess.ID, &systemAgent, content)
}
```

### 2.2 在 DependencyService.notify_only 中使用

`internal/dependency/service.go` 中，注入 `sessionRepo`：

```go
package dependency

import (
	"context"

	"gorm.io/gorm"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

type Service struct {
	db          *gorm.DB
	taskRepo    *task.Repository
	sessionRepo *session.Repository
}

func NewService(db *gorm.DB, taskRepo *task.Repository, sessionRepo *session.Repository) *Service {
	return &Service{
		db:          db,
		taskRepo:    taskRepo,
		sessionRepo: sessionRepo,
	}
}
```

修改 `OnTaskOrStepDone` 中 `notify_only` 分支（假设你能拿到 userID，或者简单情况下系统只给自己用，可以传任务 owner）：

```go
func (s *Service) OnTaskOrStepDone(
	ctx context.Context,
	predecessorTaskID uint64,
	predecessorStepID *uint64,
) error {
	return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		var deps []TaskDependency

		q := tx.Where("predecessor_task_id = ?", predecessorTaskID)
		if predecessorStepID != nil {
			q = q.Where("predecessor_step_id = ?", *predecessorStepID).
				Where("condition = ?", "step_done")
		} else {
			q = q.Where("predecessor_step_id IS NULL").
				Where("condition = ?", "task_done")
		}

		if err := q.Find(&deps).Error; err != nil {
			return err
		}
		if len(deps) == 0 {
			return nil
		}

		for _, d := range deps {
			switch d.Action {
			case "unlock_step":
				// ... 同之前示例

			case "set_task_todo":
				// ... 同之前示例

			case "notify_only":
				// 简化：找到后续任务的 owner，然后写一条系统消息
				var t task.Task
				if err := tx.First(&t, d.SuccessorTaskID).Error; err != nil {
					return err
				}

				// 这里 sessionRepo 用 tx 替换（你可以为 Repository 增加 WithTx）
				sessRepoTx := s.sessionRepo.WithTx(tx)

				content := "前置任务或步骤已经完成，后续任务/步骤已满足依赖条件。"
				if err := sessRepoTx.CreateSystemMessageForTask(ctx, t.UserID, d.SuccessorTaskID, content); err != nil {
					return err
				}
			}
		}

		return nil
	})
}
```

> 这样，当依赖设置为 `notify_only` 时，就会在后续任务对应的会话里出现一条系统消息，前端可以当成“系统提示气泡”渲染出来。

## 升级后端到GORM

好，那我把你现在的后端“升级”为 GORM 版本，整理成一套**可以直接替换进项目的代码骨架**，重点覆盖你说的三件事：

1. 用 `NewGormDB` + `AutoMigrate` 初始化数据库
2. 仓库全部改用 `*gorm.DB`（Task / Session / Dependency）
3. 依赖触发时用 `CreateSystemMessageForTask` 写系统提示

你可以直接按文件抄过去，把之前 `database/sql` 相关都删掉即可。

---

## 1. GORM 初始化 + AutoMigrate

### 1.1 `internal/db/gorm.go`

```go
package db

import (
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// NewGormDB 初始化 GORM，适配 2C / 2G 小机器
func NewGormDB(dsn string) (*gorm.DB, error) {
	cfg := &gorm.Config{
		Logger:      logger.Default.LogMode(logger.Warn),
		PrepareStmt: true,
	}

	db, err := gorm.Open(mysql.Open(dsn), cfg)
	if err != nil {
		return nil, err
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	sqlDB.SetMaxOpenConns(5)
	sqlDB.SetMaxIdleConns(5)
	sqlDB.SetConnMaxLifetime(1 * time.Hour)

	if err := sqlDB.Ping(); err != nil {
		return nil, err
	}
	return db, nil
}
```

### 1.2 `internal/db/migrate.go`

假设你已有这些模型（我们之前已经写过）：

* `auth.User` / `auth.UserLLMSetting`
* `task.Task` / `task.TaskStep`
* `dependency.TaskDependency`
* `session.Session` / `session.Message`

```go
package db

import (
	"gorm.io/gorm"

	"your-module-name/internal/auth"
	"your-module-name/internal/dependency"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

func AutoMigrate(db *gorm.DB) error {
	return db.AutoMigrate(
		&auth.User{},
		&auth.UserLLMSetting{},
		&task.Task{},
		&task.TaskStep{},
		&dependency.TaskDependency{},
		&session.Session{},
		&session.Message{},
	)
}
```

### 1.3 `cmd/server/main.go` 替换

```go
package main

import (
	"log"

	"your-module-name/internal/config"
	"your-module-name/internal/db"
	"your-module-name/internal/http"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	gormDB, err := db.NewGormDB(cfg.DatabaseDSN)
	if err != nil {
		log.Fatalf("connect db: %v", err)
	}

	if err := db.AutoMigrate(gormDB); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	r := http.NewRouter(cfg, gormDB)

	if err := r.Run(":" + cfg.HTTPPort); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
```

> 至此：后端正式用上 GORM，且自动建表/更新表结构。

---

## 2. 仓库全部改用 *gorm.DB

### 2.1 Task 仓库（含动态 UPDATE）

`internal/task/repo_gorm.go`：

```go
package task

import (
	"context"
	"time"

	"gorm.io/gorm"

	"your-module-name/internal/agent"
)

// GORM 模型 Task / TaskStep 见之前代码，这里只写 repo

type Repository struct {
	db *gorm.DB
}

func NewRepository(db *gorm.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) WithTx(tx *gorm.DB) *Repository {
	return &Repository{db: tx}
}

// —— 动态 UPDATE 的 map 构造 —— //

func buildTaskUpdateMap(fields agent.UpdateTaskFields) (map[string]any, error) {
	updates := make(map[string]any)

	if fields.Title != nil {
		updates["title"] = *fields.Title
	}
	if fields.Description != nil {
		updates["description"] = *fields.Description
	}
	if fields.Status != nil {
		updates["status"] = *fields.Status
	}
	if fields.Priority != nil {
		updates["priority"] = *fields.Priority
	}
	if fields.DueAt != nil {
		if *fields.DueAt == "" {
			updates["due_at"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.DueAt)
			if err != nil {
				return nil, err
			}
			updates["due_at"] = t
		}
	}

	return updates, nil
}

func buildStepUpdateMap(fields agent.UpdateStepFields) (map[string]any, error) {
	updates := make(map[string]any)

	if fields.Title != nil {
		updates["title"] = *fields.Title
	}
	if fields.Detail != nil {
		updates["detail"] = *fields.Detail
	}
	if fields.Status != nil {
		updates["status"] = *fields.Status
	}
	if fields.BlockingReason != nil {
		updates["blocking_reason"] = *fields.BlockingReason
	}
	if fields.EstimateMin != nil {
		updates["estimate_minutes"] = *fields.EstimateMin
	}
	if fields.OrderIndex != nil {
		updates["order_index"] = *fields.OrderIndex
	}
	if fields.PlannedStart != nil {
		if *fields.PlannedStart == "" {
			updates["planned_start"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.PlannedStart)
			if err != nil {
				return nil, err
			}
			updates["planned_start"] = t
		}
	}
	if fields.PlannedEnd != nil {
		if *fields.PlannedEnd == "" {
			updates["planned_end"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.PlannedEnd)
			if err != nil {
				return nil, err
			}
			updates["planned_end"] = t
		}
	}

	return updates, nil
}

// —— 公开方法 —— //

// 根据部分字段更新 task
func (r *Repository) ApplyUpdateTaskFields(
	ctx context.Context,
	userID, taskID uint64,
	fields agent.UpdateTaskFields,
) error {
	updates, err := buildTaskUpdateMap(fields)
	if err != nil {
		return err
	}
	if len(updates) == 0 {
		return nil
	}

	return r.db.WithContext(ctx).
		Model(&Task{}).
		Where("id = ? AND user_id = ?", taskID, userID).
		Updates(updates).Error
}

// 根据部分字段更新 step
func (r *Repository) ApplyUpdateStepFields(
	ctx context.Context,
	userID, taskID, stepID uint64,
	fields agent.UpdateStepFields,
) error {
	updates, err := buildStepUpdateMap(fields)
	if err != nil {
		return err
	}
	if len(updates) == 0 {
		return nil
	}

	// 利用子查询保证该 step 属于当前用户的 task
	subQuery := r.db.
		Select("id").
		Table("tasks").
		Where("id = ? AND user_id = ?", taskID, userID)

	return r.db.WithContext(ctx).
		Model(&TaskStep{}).
		Where("id = ? AND task_id IN (?)", stepID, subQuery).
		Updates(updates).Error
}
```

> 其它 CRUD（获取 TaskWithSteps / 插入新 steps 等）你可以继续在这个 repo 里用 GORM 写。

---

### 2.2 Session 仓库 + 系统消息封装

`internal/session/repo_gorm.go`：

```go
package session

import (
	"context"

	"gorm.io/gorm"
)

type Repository struct {
	db *gorm.DB
}

func NewRepository(db *gorm.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) WithTx(tx *gorm.DB) *Repository {
	return &Repository{db: tx}
}

func (r *Repository) GetSession(ctx context.Context, id uint64) (*Session, error) {
	var s Session
	if err := r.db.WithContext(ctx).First(&s, id).Error; err != nil {
		return nil, err
	}
	return &s, nil
}

func (r *Repository) ListRecentMessages(ctx context.Context, sessionID uint64, limit int) ([]Message, error) {
	var msgs []Message
	err := r.db.WithContext(ctx).
		Where("session_id = ?", sessionID).
		Order("created_at DESC").
		Limit(limit).
		Find(&msgs).Error
	if err != nil {
		return nil, err
	}
	// 前面按 DESC 排，必要的话你可以在代码里反转成正序展示
	return msgs, nil
}

// -------- 系统消息相关 -------- //

// 针对某个 user+task 获取/创建一个 task session
func (r *Repository) GetTaskSessionOrCreate(ctx context.Context, userID, taskID uint64) (*Session, error) {
	var sess Session
	err := r.db.WithContext(ctx).
		Where("user_id = ? AND task_id = ? AND type = 'task'", userID, taskID).
		First(&sess).Error
	if err == nil {
		return &sess, nil
	}
	if err != gorm.ErrRecordNotFound {
		return nil, err
	}

	sess = Session{
		UserID: userID,
		TaskID: &taskID,
		Type:   "task",
	}
	if err := r.db.WithContext(ctx).Create(&sess).Error; err != nil {
		return nil, err
	}
	return &sess, nil
}

// 在 session 写一条 system 消息
func (r *Repository) CreateSystemMessage(ctx context.Context, sessionID uint64, agentName *string, content string) error {
	msg := Message{
		SessionID: sessionID,
		Role:      "system",
		AgentName: agentName,
		Content:   content,
	}
	return r.db.WithContext(ctx).Create(&msg).Error
}

// 方便依赖服务：针对任务写系统消息
func (r *Repository) CreateSystemMessageForTask(
	ctx context.Context,
	userID, taskID uint64,
	content string,
) error {
	sess, err := r.GetTaskSessionOrCreate(ctx, userID, taskID)
	if err != nil {
		return err
	}
	systemAgent := "system"
	return r.CreateSystemMessage(ctx, sess.ID, &systemAgent, content)
}
```

---

### 2.3 DependencyService 用 *gorm.DB + 系统消息

`internal/dependency/service.go`：

```go
package dependency

import (
	"context"

	"gorm.io/gorm"

	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

type Service struct {
	db          *gorm.DB
	taskRepo    *task.Repository
	sessionRepo *session.Repository
}

func NewService(db *gorm.DB, taskRepo *task.Repository, sessionRepo *session.Repository) *Service {
	return &Service{
		db:          db,
		taskRepo:    taskRepo,
		sessionRepo: sessionRepo,
	}
}

// predecessorStepID == nil 表示“整个任务完成”触发
func (s *Service) OnTaskOrStepDone(
	ctx context.Context,
	predecessorTaskID uint64,
	predecessorStepID *uint64,
) error {
	return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		var deps []TaskDependency

		q := tx.Where("predecessor_task_id = ?", predecessorTaskID)
		if predecessorStepID != nil {
			q = q.Where("predecessor_step_id = ?", *predecessorStepID).
				Where("condition = ?", "step_done")
		} else {
			q = q.Where("predecessor_step_id IS NULL").
				Where("condition = ?", "task_done")
		}

		if err := q.Find(&deps).Error; err != nil {
			return err
		}
		if len(deps) == 0 {
			return nil
		}

		// 用 Tx 包装 repo
		taskRepoTx := s.taskRepo.WithTx(tx)
		sessionRepoTx := s.sessionRepo.WithTx(tx)

		for _, d := range deps {
			switch d.Action {
			case "unlock_step":
				if d.SuccessorStepID == nil {
					continue
				}
				// 仅在 locked -> todo
				if err := tx.Model(&task.TaskStep{}).
					Where("id = ? AND task_id = ? AND status = ?", *d.SuccessorStepID, d.SuccessorTaskID, "locked").
					Update("status", "todo").Error; err != nil {
					return err
				}

			case "set_task_todo":
				if err := tx.Model(&task.Task{}).
					Where("id = ? AND status != ?", d.SuccessorTaskID, "done").
					Update("status", "todo").Error; err != nil {
					return err
				}

			case "notify_only":
				// 查后续任务 owner，用系统消息提醒
				var t task.Task
				if err := tx.First(&t, d.SuccessorTaskID).Error; err != nil {
					return err
				}
				content := "前置任务或步骤已经完成，后续任务/步骤已满足依赖条件。"
				if err := sessionRepoTx.CreateSystemMessageForTask(ctx, t.UserID, d.SuccessorTaskID, content); err != nil {
					return err
				}
			}

			// 如果你想在解锁/激活任务后再做别的事，也可以在这里调用其它服务
			_ = taskRepoTx // 用于后续扩展
		}

		return nil
	})
}
```

> 后续你要在上层 service 里，当某个任务/步骤状态被 LLM 设置为 `done` 时，调用：

```go
if fields.Status != nil && *fields.Status == "done" {
    if err := dependencySvc.OnTaskOrStepDone(ctx, taskID, &stepID); err != nil {
        return err
    }
}
```

---

## 3. 路由层对接 GORM 版本 repo/service

最后提醒你改一下 `internal/http/router.go` 的签名，从 `*sql.DB` 换成 `*gorm.DB`，并用新 repo/service：

```go
package http

import (
	"gorm.io/gorm"

	"your-module-name/internal/agent"
	"your-module-name/internal/auth"
	"your-module-name/internal/config"
	"your-module-name/internal/dependency"
	"your-module-name/internal/llm"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

func NewRouter(cfg *config.Config, db *gorm.DB) *gin.Engine {
	r := gin.Default()

	// Auth
	jwtMgr := auth.NewJWTManager(cfg.JWTSecret)
	authSvc := auth.NewServiceGorm(db, jwtMgr) // 你可以写一个用 gorm 的版本

	// Repo & Service
	taskRepo := task.NewRepository(db)
	sessionRepo := session.NewRepository(db)
	depSvc := dependency.NewService(db, taskRepo, sessionRepo)

	llmClient := llm.NewHTTPClient()
	agentRouter := agent.NewSimpleRouter()
	executorAgent := agent.NewExecutorAgent(llmClient)
	// planner/global/summarizer 也在这里初始化

	agentSvc := agent.NewService(agentRouter, []agent.Agent{executorAgent}, taskRepo, sessionRepo, depSvc)

	// Handler 初始化...
	// authHandler := ...
	// taskHandler := ...
	// sessionHandler := ...

	return r
}
```

> 这里我只给结构示意，具体你按前面已有的 Handler 代码接一下即可（主要是把 db 类型替换成 `*gorm.DB`，并把依赖服务注入到 `AgentService` 或上层 Service 中）。