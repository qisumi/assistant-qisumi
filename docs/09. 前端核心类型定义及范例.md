那我就直接给你一套可以「拎起来就改」的前端样板：

* 一份核心 **TypeScript 类型定义**（Task / Step / Session / Message 等）
* 一个基于 **Ant Design + React Query + React Router** 的 `TaskDetailPage`
* 一个可复用的 `ChatWindow` 组件

你可以按自己的项目结构拆成多个文件，我下面用常见的目录风格来写。

---

## 1. TypeScript 类型定义（`src/types/index.ts`）

```ts
// src/types/index.ts

// 任务状态
export type TaskStatus = 'todo' | 'in_progress' | 'done' | 'cancelled';

// 步骤状态
export type StepStatus = 'locked' | 'todo' | 'in_progress' | 'done' | 'blocked';

// 优先级
export type TaskPriority = 'low' | 'medium' | 'high';

// 会话类型
export type SessionType = 'task' | 'global';

// 消息角色
export type MessageRole = 'user' | 'assistant' | 'system';

// Agent 名称（后端 messages.agent_name）
export type AgentName =
  | 'executor'
  | 'planner'
  | 'summarizer'
  | 'global'
  | 'system'
  | null;

export interface TaskStep {
  id: number;
  taskId: number;
  orderIndex: number;
  title: string;
  detail: string;
  status: StepStatus;
  blockingReason?: string | null;
  estimateMinutes?: number | null;
  plannedStart?: string | null; // ISO 字符串
  plannedEnd?: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface Task {
  id: number;
  userId: number;
  title: string;
  description: string;
  status: TaskStatus;
  priority: TaskPriority;
  dueAt?: string | null;
  createdAt: string;
  updatedAt: string;
  steps?: TaskStep[];
}

// 任务详情 API 返回值（示例，可按后端调整）
export interface TaskDetailResponse {
  task: Task;
  session: Session;
  // 可选：也可以单独调用获取 messages
  messages?: Message[];
}

export interface Session {
  id: number;
  userId: number;
  taskId?: number | null;
  type: SessionType;
  createdAt: string;
}

export interface Message {
  id: number;
  sessionId: number;
  role: MessageRole;
  agentName?: AgentName;
  content: string;
  createdAt: string;
}

// 会话消息接口返回
export interface SessionMessagesResponse {
  messages: Message[];
}

// 发送消息接口返回（示例）
export interface SendMessageResponse {
  assistantMessage: string;
  taskPatches?: unknown; // 如果你要在前端也可视化 patch 可以细化类型
}
```

---

## 2. 简易 API 封装（可选，方便样板跑起来）

### 2.1 `src/api/client.ts`

```ts
// src/api/client.ts
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL ?? 'http://localhost:4569/api';

const apiClient = axios.create({
  baseURL: API_BASE_URL,
});

// 简单附加 JWT
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers = config.headers ?? {};
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  return config;
});

export default apiClient;
```

### 2.2 `src/api/tasks.ts`

```ts
// src/api/tasks.ts
import apiClient from './client';
import type { TaskDetailResponse } from '@/types';

export async function fetchTaskDetail(taskId: string | number): Promise<TaskDetailResponse> {
  const { data } = await apiClient.get<TaskDetailResponse>(`/tasks/${taskId}`);
  return data;
}
```

### 2.3 `src/api/sessions.ts`

```ts
// src/api/sessions.ts
import apiClient from './client';
import type { SessionMessagesResponse, SendMessageResponse } from '@/types';

export async function fetchSessionMessages(
  sessionId: number | string,
): Promise<SessionMessagesResponse> {
  const { data } = await apiClient.get<SessionMessagesResponse>(`/sessions/${sessionId}/messages`);
  return data;
}

export async function sendSessionMessage(
  sessionId: number | string,
  content: string,
): Promise<SendMessageResponse> {
  const { data } = await apiClient.post<SendMessageResponse>(
    `/sessions/${sessionId}/messages`,
    { content },
  );
  return data;
}
```

> 注意：这里的 URL 你要对齐后端实际路由，例如之前我们设计的是 `POST /api/sessions/:id/messages`，`GET /api/tasks/:id/messages`，你可以稍作调整。

---

## 3. ChatWindow 组件（`src/components/chat/ChatWindow.tsx`）

使用 Ant Design 的 `List` + `Input.TextArea` + `Button`，支持自动滚动到底部、发送中 loading 等。

```tsx
// src/components/chat/ChatWindow.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { Avatar, Button, Input, List, Space, Tag, Typography } from 'antd';
import type { Message } from '@/types';

const { TextArea } = Input;
const { Text } = Typography;

export interface ChatWindowProps {
  messages: Message[];
  onSend: (content: string) => Promise<void>;
  sending?: boolean;
  height?: number | string; // 容器高度，默认 400
}

const roleLabelMap: Record<string, string> = {
  user: '我',
  assistant: '助手',
  system: '系统',
};

const agentColorMap: Record<string, string> = {
  executor: 'blue',
  planner: 'purple',
  summarizer: 'geekblue',
  global: 'volcano',
  system: 'default',
};

export const ChatWindow: React.FC<ChatWindowProps> = ({
  messages,
  onSend,
  sending = false,
  height = 400,
}) => {
  const [input, setInput] = useState('');
  const listRef = useRef<HTMLDivElement | null>(null);

  // 把 messages 转成按时间升序显示
  const sortedMessages = useMemo(
    () => [...messages].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()),
    [messages],
  );

  // 滚动到底部
  useEffect(() => {
    if (listRef.current) {
      listRef.current.scrollTop = listRef.current.scrollHeight;
    }
  }, [sortedMessages.length]);

  const handleSend = async () => {
    const content = input.trim();
    if (!content || sending) return;
    setInput('');
    await onSend(content);
  };

  const handlePressEnter: React.KeyboardEventHandler<HTMLTextAreaElement> = (e) => {
    if (!e.shiftKey) {
      e.preventDefault();
      void handleSend();
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height }}>
      <div
        ref={listRef}
        style={{
          flex: 1,
          overflowY: 'auto',
          padding: '8px 12px',
          background: '#f5f5f5',
          borderRadius: 8,
          marginBottom: 8,
        }}
      >
        <List
          dataSource={sortedMessages}
          renderItem={(msg) => {
            const isUser = msg.role === 'user';
            const isSystem = msg.role === 'system';
            const agentName = msg.agentName ?? undefined;
            const agentColor = agentName ? agentColorMap[agentName] ?? 'default' : 'default';

            return (
              <List.Item
                style={{
                  border: 'none',
                  padding: '4px 0',
                  justifyContent: isUser ? 'flex-end' : 'flex-start',
                }}
              >
                <Space
                  align="start"
                  style={{
                    maxWidth: '80%',
                    flexDirection: isUser ? 'row-reverse' : 'row',
                  }}
                >
                  <Avatar size="small">
                    {roleLabelMap[msg.role]?.[0] ?? 'A'}
                  </Avatar>
                  <div
                    style={{
                      background: isSystem ? 'transparent' : isUser ? '#1677ff' : '#fff',
                      color: isSystem ? '#999' : isUser ? '#fff' : '#000',
                      borderRadius: 8,
                      padding: isSystem ? 0 : '6px 10px',
                      boxShadow: isSystem ? 'none' : '0 1px 3px rgba(0,0,0,0.08)',
                    }}
                  >
                    {/* 角色 + Agent 标签行 */}
                    {!isSystem && (
                      <div style={{ marginBottom: 2 }}>
                        <Space size={4}>
                          <Text
                            type="secondary"
                            style={{
                              fontSize: 11,
                              color: isUser ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.45)',
                            }}
                          >
                            {roleLabelMap[msg.role] ?? msg.role}
                          </Text>
                          {agentName && (
                            <Tag
                              color={agentColor}
                              style={{
                                height: 18,
                                lineHeight: '14px',
                                fontSize: 10,
                                borderRadius: 4,
                              }}
                            >
                              {agentName}
                            </Tag>
                          )}
                        </Space>
                      </div>
                    )}
                    <div style={{ whiteSpace: 'pre-wrap', fontSize: 13 }}>
                      {msg.content}
                    </div>
                  </div>
                </Space>
              </List.Item>
            );
          }}
        />
      </div>

      <div>
        <TextArea
          autoSize={{ minRows: 2, maxRows: 4 }}
          placeholder="在这里输入内容，Enter 发送，Shift+Enter 换行"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onPressEnter={handlePressEnter}
        />
        <div style={{ marginTop: 4, textAlign: 'right' }}>
          <Button type="primary" onClick={handleSend} loading={sending}>
            发送
          </Button>
        </div>
      </div>
    </div>
  );
};
```

---

## 4. TaskDetailPage 样板（`src/pages/Tasks/TaskDetailPage.tsx`）

这个页面做三件事：

1. 根据 URL 上的 `taskId` 拉取任务详情（含 steps + sessionId）
2. 拉取该 session 的消息列表
3. 把消息 + 发送函数交给 `ChatWindow`

用到：

* `@tanstack/react-query`
* `react-router-dom`
* `antd`

```tsx
// src/pages/Tasks/TaskDetailPage.tsx
import React, { useMemo } from 'react';
import { useParams } from 'react-router-dom';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, Col, Descriptions, Divider, List, Progress, Row, Space, Spin, Tag, Typography, message as antdMessage } from 'antd';
import dayjs from 'dayjs';

import { fetchTaskDetail } from '@/api/tasks';
import { fetchSessionMessages, sendSessionMessage } from '@/api/sessions';
import type { Message, Task, TaskStep } from '@/types';
import { ChatWindow } from '@/components/chat/ChatWindow';

const { Title, Text, Paragraph } = Typography;

const priorityColorMap: Record<Task['priority'], string> = {
  low: 'default',
  medium: 'blue',
  high: 'red',
};

function calcProgress(steps?: TaskStep[]): number {
  if (!steps || steps.length === 0) return 0;
  const done = steps.filter((s) => s.status === 'done').length;
  return Math.round((done / steps.length) * 100);
}

export const TaskDetailPage: React.FC = () => {
  const { taskId } = useParams<{ taskId: string }>();
  const queryClient = useQueryClient();

  const {
    data: taskDetail,
    isLoading: loadingTask,
    isError: taskError,
  } = useQuery({
    queryKey: ['taskDetail', taskId],
    queryFn: () => fetchTaskDetail(taskId!),
    enabled: !!taskId,
  });

  const sessionId = taskDetail?.session.id;

  const {
    data: messagesData,
    isLoading: loadingMessages,
  } = useQuery({
    queryKey: ['sessionMessages', sessionId],
    queryFn: () => fetchSessionMessages(sessionId!),
    enabled: !!sessionId,
    // 定时轮询也可以打开：
    // refetchInterval: 5000,
  });

  const messages: Message[] = messagesData?.messages ?? [];

  const sendMutation = useMutation({
    mutationFn: (content: string) => sendSessionMessage(sessionId!, content),
    onSuccess: async () => {
      // 发完消息以后刷新消息列表 & 任务详情（以获取最新 steps 状态）
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ['sessionMessages', sessionId] }),
        queryClient.invalidateQueries({ queryKey: ['taskDetail', taskId] }),
      ]);
    },
    onError: (err: any) => {
      console.error(err);
      antdMessage.error('发送失败，请稍后重试');
    },
  });

  const task = taskDetail?.task;
  const steps = task?.steps ?? [];

  const progress = useMemo(() => calcProgress(steps), [steps]);

  if (loadingTask) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <Spin />
      </div>
    );
  }

  if (taskError || !task) {
    return (
      <div style={{ padding: 24 }}>
        <Text type="danger">加载任务信息失败</Text>
      </div>
    );
  }

  const isOverdue =
    task.dueAt && dayjs(task.dueAt).isBefore(dayjs(), 'day') && task.status !== 'done';

  return (
    <div style={{ padding: 24 }}>
      <Row gutter={16}>
        {/* 左侧：任务信息 + 步骤列表 */}
        <Col xs={24} lg={10}>
          <Card>
            <Space direction="vertical" style={{ width: '100%' }} size="middle">
              <div>
                <Title level={4} style={{ marginBottom: 4 }}>
                  {task.title}
                </Title>
                <Space size="small">
                  <Tag color={priorityColorMap[task.priority]}>
                    优先级：{task.priority === 'high' ? '高' : task.priority === 'medium' ? '中' : '低'}
                  </Tag>
                  <Tag color={task.status === 'done' ? 'green' : task.status === 'in_progress' ? 'blue' : 'default'}>
                    状态：{statusToText(task.status)}
                  </Tag>
                  {isOverdue && <Tag color="red">已过期</Tag>}
                </Space>
              </div>

              {task.description && (
                <Paragraph style={{ whiteSpace: 'pre-wrap' }}>{task.description}</Paragraph>
              )}

              <Descriptions size="small" column={1}>
                <Descriptions.Item label="截止时间">
                  {task.dueAt ? dayjs(task.dueAt).format('YYYY-MM-DD HH:mm') : <Text type="secondary">无</Text>}
                </Descriptions.Item>
                <Descriptions.Item label="创建时间">
                  {dayjs(task.createdAt).format('YYYY-MM-DD HH:mm')}
                </Descriptions.Item>
                <Descriptions.Item label="最近更新">
                  {dayjs(task.updatedAt).format('YYYY-MM-DD HH:mm')}
                </Descriptions.Item>
              </Descriptions>

              <div>
                <Text type="secondary" style={{ marginRight: 8 }}>
                  完成进度
                </Text>
                <Progress percent={progress} size="small" />
              </div>
            </Space>
          </Card>

          <Divider />

          <Card title="步骤列表">
            {steps.length === 0 ? (
              <Text type="secondary">当前任务还没有步骤。</Text>
            ) : (
              <List
                itemLayout="vertical"
                dataSource={steps.sort((a, b) => a.orderIndex - b.orderIndex)}
                renderItem={(step) => (
                  <List.Item key={step.id}>
                    <Space direction="vertical" style={{ width: '100%' }} size={4}>
                      <Space>
                        <Text strong>
                          {step.orderIndex}. {step.title}
                        </Text>
                        <StepStatusTag status={step.status} />
                        {step.estimateMinutes && (
                          <Tag color="default">{step.estimateMinutes} 分钟</Tag>
                        )}
                        {step.plannedStart && (
                          <Tag color="geekblue">
                            计划：{dayjs(step.plannedStart).format('MM-DD HH:mm')}~
                            {step.plannedEnd ? dayjs(step.plannedEnd).format('HH:mm') : ''}
                          </Tag>
                        )}
                      </Space>
                      {step.detail && (
                        <Text type="secondary" style={{ fontSize: 12, whiteSpace: 'pre-wrap' }}>
                          {step.detail}
                        </Text>
                      )}
                      {step.status === 'blocked' && step.blockingReason && (
                        <Text type="danger" style={{ fontSize: 12 }}>
                          阻塞原因：{step.blockingReason}
                        </Text>
                      )}
                    </Space>
                  </List.Item>
                )}
              />
            )}
          </Card>
        </Col>

        {/* 右侧：对话窗口 */}
        <Col xs={24} lg={14}>
          <Card
            title="任务会话"
            extra={
              loadingMessages ? (
                <Text type="secondary" style={{ fontSize: 12 }}>
                  正在刷新…
                </Text>
              ) : null
            }
          >
            <ChatWindow
              messages={messages}
              onSend={(content) => sendMutation.mutateAsync(content)}
              sending={sendMutation.isPending}
              height={520}
            />
          </Card>
        </Col>
      </Row>
    </div>
  );
};

function statusToText(status: Task['status']): string {
  switch (status) {
    case 'todo':
      return '待开始';
    case 'in_progress':
      return '进行中';
    case 'done':
      return '已完成';
    case 'cancelled':
      return '已取消';
    default:
      return status;
  }
}

const StepStatusTag: React.FC<{ status: TaskStep['status'] }> = ({ status }) => {
  switch (status) {
    case 'locked':
      return <Tag color="default">未解锁</Tag>;
    case 'todo':
      return <Tag color="default">待办</Tag>;
    case 'in_progress':
      return <Tag color="blue">进行中</Tag>;
    case 'done':
      return <Tag color="green">已完成</Tag>;
    case 'blocked':
      return <Tag color="red">阻塞</Tag>;
    default:
      return <Tag>{status}</Tag>;
  }
};
```

> 你只需要在路由里加一句：
> ` <Route path="/tasks/:taskId" element={<TaskDetailPage />} />`
> 再把 `fetchTaskDetail` / `fetchSessionMessages` 的 URL 对齐后端，就能跑通一个端到端的 Demo。

---

如果你接下来想继续，我可以帮你：

* 写一个 `CreateFromTextPage` 的样板（粘贴文本 → 调后端 → 跳转到 TaskDetail），或者
* 帮你把 `GlobalAssistantPage`（“我今天要做什么？”的全局聊天页）也按同样模式写出来。
