好，那我就直接给你一套可以「从 LLM tool calls → TaskPatch → DB 更新」的设计方案，包含：

1. `TaskPatch` 的 Go 结构定义
2. 每个 tool 对应的 `Args` 结构体
3. 从 tool 调用 arguments 映射到 `[]TaskPatch` 的示例代码
4. 如何在 `ApplyTaskPatches` 里根据 `TaskPatch` 落库的示例

你可以按需精简 / 修改字段名。

---

## 1. TaskPatch 结构设计

思路：

* 用一个枚举 `PatchKind` 表示 patch 类型
* 每种类型有自己的 payload struct
* 顶层 `TaskPatch` 作为「标记类型 + payload 指针」的 union

建议放到 `internal/agent/patch.go`：

```go
package agent

type PatchKind string

const (
	PatchUpdateTask          PatchKind = "update_task"
	PatchUpdateStep          PatchKind = "update_step"
	PatchAddSteps            PatchKind = "add_steps"
	PatchAddDependencies     PatchKind = "add_dependencies"
	PatchMarkTasksFocusToday PatchKind = "mark_tasks_focus_today"
)

// 顶层 Patch，Kind 决定哪个字段非 nil
type TaskPatch struct {
	Kind PatchKind `json:"kind"`

	UpdateTask          *UpdateTaskPatch          `json:"update_task,omitempty"`
	UpdateStep          *UpdateStepPatch          `json:"update_step,omitempty"`
	AddSteps            *AddStepsPatch            `json:"add_steps,omitempty"`
	AddDependencies     *AddDependenciesPatch     `json:"add_dependencies,omitempty"`
	MarkTasksFocusToday *MarkTasksFocusTodayPatch `json:"mark_tasks_focus_today,omitempty"`
}

// --- 各种具体 Patch Payload ---

type UpdateTaskPatch struct {
	TaskID uint64            `json:"task_id"`
	Fields UpdateTaskFields  `json:"fields"`
}

type UpdateTaskFields struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`   // "todo" | "in_progress" | "done" | "cancelled"
	Priority    *string `json:"priority,omitempty"` // "low" | "medium" | "high"
	DueAt       *string `json:"due_at,omitempty"`   // ISO 8601
}

type UpdateStepPatch struct {
	TaskID uint64           `json:"task_id"`
	StepID uint64           `json:"step_id"`
	Fields UpdateStepFields `json:"fields"`
}

type UpdateStepFields struct {
	Title          *string `json:"title,omitempty"`
	Detail         *string `json:"detail,omitempty"`
	Status         *string `json:"status,omitempty"` // "locked" | "todo" | "in_progress" | "done" | "blocked"
	BlockingReason *string `json:"blocking_reason,omitempty"`
	EstimateMin    *int    `json:"estimate_minutes,omitempty"`
	OrderIndex     *int    `json:"order_index,omitempty"`
	PlannedStart   *string `json:"planned_start,omitempty"` // ISO 8601
	PlannedEnd     *string `json:"planned_end,omitempty"`   // ISO 8601
}

type AddStepsPatch struct {
	TaskID        uint64          `json:"task_id"`
	ParentStepID  *uint64         `json:"parent_step_id,omitempty"`
	StepsToInsert []NewStepRecord `json:"steps_to_insert"`
}

type NewStepRecord struct {
	Title             string  `json:"title"`
	Detail            string  `json:"detail"`
	EstimateMinutes   *int    `json:"estimate_minutes,omitempty"`
	InsertAfterStepID *uint64 `json:"insert_after_step_id,omitempty"`
}

type AddDependenciesPatch struct {
	Items []DependencyItem `json:"items"`
}

type DependencyItem struct {
	PredecessorTaskID uint64  `json:"predecessor_task_id"`
	PredecessorStepID *uint64 `json:"predecessor_step_id,omitempty"`
	SuccessorTaskID   uint64  `json:"successor_task_id"`
	SuccessorStepID   *uint64 `json:"successor_step_id,omitempty"`
	Condition         string  `json:"condition"` // "task_done" | "step_done"
	Action            string  `json:"action"`    // "unlock_step" | "set_task_todo" | "notify_only"
}

type MarkTasksFocusTodayPatch struct {
	TaskIDs []uint64 `json:"task_ids"`
}
```

> 这部分完全独立于 LLM；后面只要把 tool arguments decode 成这些 patch，就可以在 Service 里统一处理。

---

## 2. Tool arguments 的 Go 结构体

现在需要为每个工具写一个 `Args` struct，用来 `json.Unmarshal` LLM 返回的 `arguments` 字符串。

建议放到 `internal/agent/tool_args.go`：

```go
package agent

// 对应 tool: update_task
type UpdateTaskArgs struct {
	TaskID uint64           `json:"task_id"`
	Fields UpdateTaskFields `json:"fields"`
}

// 对应 tool: update_steps
type UpdateStepsArgs struct {
	TaskID  uint64               `json:"task_id"`
	Updates []UpdateStepItemArgs `json:"updates"`
}

type UpdateStepItemArgs struct {
	StepID uint64           `json:"step_id"`
	Fields UpdateStepFields `json:"fields"`
}

// 对应 tool: add_steps
type AddStepsArgs struct {
	TaskID       uint64             `json:"task_id"`
	ParentStepID *uint64            `json:"parent_step_id"`
	Steps        []NewStepArgsInput `json:"steps"`
}

type NewStepArgsInput struct {
	Title             string `json:"title"`
	Detail            string `json:"detail"`
	EstimateMinutes   *int   `json:"estimate_minutes"`
	InsertAfterStepID *uint64 `json:"insert_after_step_id"`
}

// 对应 tool: add_dependencies
type AddDependenciesArgs struct {
	Items []DependencyItemArgs `json:"items"`
}

type DependencyItemArgs struct {
	PredecessorTaskID uint64  `json:"predecessor_task_id"`
	PredecessorStepID *uint64 `json:"predecessor_step_id"`
	SuccessorTaskID   uint64  `json:"successor_task_id"`
	SuccessorStepID   *uint64 `json:"successor_step_id"`
	Condition         string  `json:"condition"`
	Action            string  `json:"action"`
}

// 对应 tool: mark_tasks_focus_today
type MarkTasksFocusTodayArgs struct {
	TaskIDs []uint64 `json:"task_ids"`
}
```

可以看到，`UpdateTaskFields` / `UpdateStepFields` 复用前面 `TaskPatch` 定义的类型（完全兼容）。

---

## 3. 从 tool 调用 → []TaskPatch：示例代码

你的 `llm.ChatResponse` 里需要有类似 OpenAI 的 `tool_calls` 结构。我们可以在 `internal/llm/client.go` 里补个结构（伪）：

```go
package llm

// 这里只给出和 tool_call 相关的部分

type Choice struct {
	Index   int      `json:"index"`
	Message ChatMessage `json:"message"`
}

type ChatMessage struct {
	Role      string      `json:"role"`
	Content   string      `json:"content,omitempty"`
	ToolCalls []ToolCall  `json:"tool_calls,omitempty"`
}

type ToolCall struct {
	ID       string          `json:"id"`
	Type     string          `json:"type"` // "function"
	Function ToolFunctionCall `json:"function"`
}

type ToolFunctionCall struct {
	Name      string `json:"name"`
	Arguments string `json:"arguments"` // JSON 字符串
}

type ChatResponse struct {
	Choices []Choice `json:"choices"`
}
```

> 实际要根据你接的服务来改，这里只是典型 OpenAI 结构。

### 3.1 映射函数：ToolCalls → []TaskPatch

建议放到 `internal/agent/tool_to_patch.go`：

```go
package agent

import (
	"encoding/json"
	"fmt"

	"your-module-name/internal/llm"
)

// 从一次 ChatResponse 中，提取所有 tool_calls 并转为 TaskPatch 列表
func BuildPatchesFromToolCalls(resp *llm.ChatResponse) ([]TaskPatch, error) {
	var patches []TaskPatch

	if len(resp.Choices) == 0 {
		return nil, nil
	}
	msg := resp.Choices[0].Message
	if len(msg.ToolCalls) == 0 {
		return nil, nil
	}

	for _, tc := range msg.ToolCalls {
		if tc.Type != "function" {
			continue
		}
		name := tc.Function.Name
		argsJSON := tc.Function.Arguments

		switch name {
		case "update_task":
			var args UpdateTaskArgs
			if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
				return nil, fmt.Errorf("update_task args decode: %w", err)
			}
			patches = append(patches, TaskPatch{
				Kind: PatchUpdateTask,
				UpdateTask: &UpdateTaskPatch{
					TaskID: args.TaskID,
					Fields: args.Fields,
				},
			})

		case "update_steps":
			var args UpdateStepsArgs
			if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
				return nil, fmt.Errorf("update_steps args decode: %w", err)
			}
			for _, u := range args.Updates {
				patches = append(patches, TaskPatch{
					Kind: PatchUpdateStep,
					UpdateStep: &UpdateStepPatch{
						TaskID: args.TaskID,
						StepID: u.StepID,
						Fields: u.Fields,
					},
				})
			}

		case "add_steps":
			var args AddStepsArgs
			if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
				return nil, fmt.Errorf("add_steps args decode: %w", err)
			}
			records := make([]NewStepRecord, 0, len(args.Steps))
			for _, s := range args.Steps {
				records = append(records, NewStepRecord{
					Title:             s.Title,
					Detail:            s.Detail,
					EstimateMinutes:   s.EstimateMinutes,
					InsertAfterStepID: s.InsertAfterStepID,
				})
			}
			patches = append(patches, TaskPatch{
				Kind: PatchAddSteps,
				AddSteps: &AddStepsPatch{
					TaskID:        args.TaskID,
					ParentStepID:  args.ParentStepID,
					StepsToInsert: records,
				},
			})

		case "add_dependencies":
			var args AddDependenciesArgs
			if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
				return nil, fmt.Errorf("add_dependencies args decode: %w", err)
			}
			items := make([]DependencyItem, 0, len(args.Items))
			for _, it := range args.Items {
				items = append(items, DependencyItem{
					PredecessorTaskID: it.PredecessorTaskID,
					PredecessorStepID: it.PredecessorStepID,
					SuccessorTaskID:   it.SuccessorTaskID,
					SuccessorStepID:   it.SuccessorStepID,
					Condition:         it.Condition,
					Action:            it.Action,
				})
			}
			patches = append(patches, TaskPatch{
				Kind: PatchAddDependencies,
				AddDependencies: &AddDependenciesPatch{
					Items: items,
				},
			})

		case "mark_tasks_focus_today":
			var args MarkTasksFocusTodayArgs
			if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
				return nil, fmt.Errorf("mark_tasks_focus_today args decode: %w", err)
			}
			patches = append(patches, TaskPatch{
				Kind: PatchMarkTasksFocusToday,
				MarkTasksFocusToday: &MarkTasksFocusTodayPatch{
					TaskIDs: args.TaskIDs,
				},
			})

		default:
			// 未知 function，可以忽略或记录日志
			// log.Printf("unknown tool function: %s", name)
		}
	}

	return patches, nil
}
```

> 这一层相当于是「LLM 输出 → 业务领域变更描述（TaskPatch）」的适配层。
> 后面所有 DB 操作都只看 `TaskPatch`，和 LLM/工具名解耦。

---

## 4. 在 Service 里应用 TaskPatch（示例）

在你的 `AgentService` 中，可能有类似：

```go
func (s *Service) applyTaskPatches(ctx context.Context, userID uint64, patches []TaskPatch) error {
	if len(patches) == 0 {
		return nil
	}

	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// 用 repo 的 Tx 版本（你可以在 repo 里分别支持 *sql.DB 或 *sql.Tx）
	taskRepo := s.taskRepo.WithTx(tx)
	depRepo := s.dependencyRepo.WithTx(tx)
	// ... 其它 repo

	for _, p := range patches {
		switch p.Kind {
		case PatchUpdateTask:
			up := p.UpdateTask
			if up == nil {
				continue
			}
			if err = taskRepo.ApplyUpdateTaskFields(ctx, userID, up.TaskID, up.Fields); err != nil {
				return err
			}

		case PatchUpdateStep:
			up := p.UpdateStep
			if up == nil {
				continue
			}
			if err = taskRepo.ApplyUpdateStepFields(ctx, userID, up.TaskID, up.StepID, up.Fields); err != nil {
				return err
			}

		case PatchAddSteps:
			ap := p.AddSteps
			if ap == nil {
				continue
			}
			if err = taskRepo.InsertNewSteps(ctx, userID, ap.TaskID, ap.ParentStepID, ap.StepsToInsert); err != nil {
				return err
			}

		case PatchAddDependencies:
			dp := p.AddDependencies
			if dp == nil {
				continue
			}
			if err = depRepo.InsertDependencies(ctx, userID, dp.Items); err != nil {
				return err
			}

		case PatchMarkTasksFocusToday:
			fp := p.MarkTasksFocusToday
			if fp == nil {
				continue
			}
			if err = taskRepo.UpdateTasksFocusToday(ctx, userID, fp.TaskIDs); err != nil {
				return err
			}
		}
	}

	// 依赖联动：比如某个步骤 done 后，自动解锁后续步骤
	// 可以在 ApplyUpdateStepFields 内部调用，也可以在这里根据 patches 再调用一个 DependencyService

	if err = tx.Commit(); err != nil {
		return err
	}
	return nil
}
```

对应的 repo 方法你可以按业务细化，比如：

```go
// internal/task/repo.go

func (r *Repository) ApplyUpdateTaskFields(ctx context.Context, userID, taskID uint64, fields UpdateTaskFields) error {
	// 根据哪些字段非 nil 拼 UPDATE 语句
	// WHERE user_id = ? AND id = ?
	// ...
	return nil
}

func (r *Repository) ApplyUpdateStepFields(ctx context.Context, userID, taskID, stepID uint64, fields UpdateStepFields) error {
	// 同理
	return nil
}

func (r *Repository) InsertNewSteps(ctx context.Context, userID, taskID uint64, parentStepID *uint64, steps []NewStepRecord) error {
	// 插入多行 step，根据 insert_after_step_id 调整 order_index
	return nil
}
```