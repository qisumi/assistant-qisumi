下面我直接给你三块内容：

1. **tools 的 Go struct 定义 + 公共 tools 构造函数**
2. **ExecutorAgent / PlannerAgent 的系统 Prompt 常量**
3. **“拼接当前任务 JSON”的示例函数**（基于你之前的 `llm.Message` / `task.Task`）

你可以把这些文件放到：

* `internal/llm/tools.go`
* `internal/agent/prompts.go`
* `internal/agent/prompt_builder.go`

按需调整包名和 import。

---

## 1. Tools schema 的 Go struct 写法

### 1.1 `internal/llm/tools.go`

```go
package llm

import "encoding/json"

// Tool 对应 OpenAI 的 tools 数组元素。
type Tool struct {
	Type     string       `json:"type"` // 固定 "function"
	Function FunctionSpec `json:"function"`
}

// FunctionSpec 对应 tools[*].function。
type FunctionSpec struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Parameters  json.RawMessage `json:"parameters"` // 存放 JSON Schema
}

// 帮助函数：把字符串转为 json.RawMessage（不做错误处理，初始化阶段 panic 重启即可）
func MustRawJSON(s string) json.RawMessage {
	return json.RawMessage(s)
}

// 返回 Executor / Planner / Global 等通用会用到的一组工具。
// 你可以按 Agent 类型拆分，这里给的是“全集示例”，按需裁剪。
func CommonTools() []Tool {
	return []Tool{
		{
			Type: "function",
			Function: FunctionSpec{
				Name:        "update_task",
				Description: "Update a task's metadata such as title, description, status, priority or due_at.",
				Parameters: MustRawJSON(`{
          "type": "object",
          "properties": {
            "task_id": { "type": "integer", "description": "The ID of the task to update." },
            "fields": {
              "type": "object",
              "description": "Fields to update. Only include fields that need to be changed.",
              "properties": {
                "title":        { "type": "string" },
                "description":  { "type": "string" },
                "status": {
                  "type": "string",
                  "enum": ["todo", "in_progress", "done", "cancelled"]
                },
                "priority": {
                  "type": "string",
                  "enum": ["low", "medium", "high"]
                },
                "due_at": {
                  "type": "string",
                  "description": "New due date time in ISO 8601 format, e.g. 2025-12-08T20:00:00"
                }
              },
              "additionalProperties": false
            }
          },
          "required": ["task_id", "fields"],
          "additionalProperties": false
        }`),
			},
		},
		{
			Type: "function",
			Function: FunctionSpec{
				Name:        "update_steps",
				Description: "Update one or more existing steps in a task.",
				Parameters: MustRawJSON(`{
          "type": "object",
          "properties": {
            "task_id": { "type": "integer" },
            "updates": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "step_id": { "type": "integer" },
                  "fields": {
                    "type": "object",
                    "properties": {
                      "title":    { "type": "string" },
                      "detail":   { "type": "string" },
                      "status": {
                        "type": "string",
                        "enum": ["locked", "todo", "in_progress", "done", "blocked"]
                      },
                      "blocking_reason": { "type": "string" },
                      "estimate_minutes": {
                        "type": "integer",
                        "minimum": 1
                      },
                      "order_index": {
                        "type": "integer",
                        "description": "New order index, smaller means earlier."
                      },
                      "planned_start": {
                        "type": "string",
                        "description": "Planned start time in ISO 8601."
                      },
                      "planned_end": {
                        "type": "string",
                        "description": "Planned end time in ISO 8601."
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "required": ["step_id", "fields"],
                "additionalProperties": false
              }
            }
          },
          "required": ["task_id", "updates"],
          "additionalProperties": false
        }`),
			},
		},
		{
			Type: "function",
			Function: FunctionSpec{
				Name:        "add_steps",
				Description: "Add new steps to an existing task.",
				Parameters: MustRawJSON(`{
          "type": "object",
          "properties": {
            "task_id": { "type": "integer" },
            "parent_step_id": {
              "type": ["integer", "null"],
              "description": "Optional parent step ID for substeps. Use null for top-level steps."
            },
            "steps": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "title":  { "type": "string" },
                  "detail": { "type": "string" },
                  "estimate_minutes": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "insert_after_step_id": {
                    "type": ["integer", "null"],
                    "description": "Insert after this step. If null, append to the end."
                  }
                },
                "required": ["title"],
                "additionalProperties": false
              }
            }
          },
          "required": ["task_id", "steps"],
          "additionalProperties": false
        }`),
			},
		},
		{
			Type: "function",
			Function: FunctionSpec{
				Name:        "add_dependencies",
				Description: "Create dependencies between tasks or steps. When the predecessor is done, the successor can be unlocked or activated.",
				Parameters: MustRawJSON(`{
          "type": "object",
          "properties": {
            "items": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "predecessor_task_id": { "type": "integer" },
                  "predecessor_step_id": {
                    "type": ["integer", "null"],
                    "description": "Optional step ID. If null, the whole task is the predecessor."
                  },
                  "successor_task_id": { "type": "integer" },
                  "successor_step_id": {
                    "type": ["integer", "null"],
                    "description": "Optional step ID. If null, the whole task is the successor."
                  },
                  "condition": {
                    "type": "string",
                    "enum": ["task_done", "step_done"]
                  },
                  "action": {
                    "type": "string",
                    "enum": ["unlock_step", "set_task_todo", "notify_only"]
                  }
                },
                "required": ["predecessor_task_id", "successor_task_id", "condition", "action"],
                "additionalProperties": false
              }
            }
          },
          "required": ["items"],
          "additionalProperties": false
        }`),
			},
		},
		{
			Type: "function",
			Function: FunctionSpec{
				Name:        "mark_tasks_focus_today",
				Description: "Mark one or more tasks as today's focus tasks, for daily planning or overview.",
				Parameters: MustRawJSON(`{
          "type": "object",
          "properties": {
            "task_ids": {
              "type": "array",
              "items": { "type": "integer" }
            }
          },
          "required": ["task_ids"],
          "additionalProperties": false
        }`),
			},
		},
	}
}

// 针对不同 Agent 按需暴露子集：

func ExecutorTools() []Tool {
	return []Tool{
		CommonTools()[0], // update_task
		CommonTools()[1], // update_steps
	}
}

func PlannerTools() []Tool {
	tools := CommonTools()
	// update_task, update_steps, add_steps, add_dependencies
	return tools[:4]
}

func GlobalTools() []Tool {
	// 只需要 mark_tasks_focus_today，或者再加 update_task 视需求
	return []Tool{
		CommonTools()[0], // update_task（可选）
		CommonTools()[4], // mark_tasks_focus_today
	}
}
```

> 这里我为了示意直接用数组切片做复用，你在真实代码里可以写得更干净一点（比如单独定义）。

---

## 2. Executor / Planner 的系统 Prompt 常量

### 2.1 `internal/agent/prompts.go`

```go
package agent

// ExecutorAgent 的系统 Prompt
const ExecutorSystemPrompt = `
你是一个执行跟踪助手（Executor Agent）。

你收到的是：
- 当前任务的结构化信息（task 和 steps），已经由系统消息提供
- 最近几轮与用户的对话历史
- 用户的最新输入（user message）

你的职责：
1. 理解用户与当前任务相关的「执行类」意图，例如：
   - 标记某个步骤已完成 / 未完成 / 进行中 / 阻塞
   - 标记整个任务为完成
   - 修改任务的截止时间、优先级、标题或描述
   - 对某一步进行轻微的补充说明（detail）
2. 如果需要修改数据，必须调用提供的工具（tools）来更新任务和步骤：
   - update_task
   - update_steps
3. 修改完成后，你需要给用户一段自然语言回复，说明你做了哪些更新，以及下一步建议。

重要原则：
- 所有对任务 / 步骤的修改必须通过工具调用完成，不能只在文字里说“我已经修改了”。
- 只使用系统消息里给出的 task_id 和 step_id，不要编造不存在的 ID。
- 如果用户说的是模糊描述（例如“我完成了读论文那一步”），你需要通过标题/detail 内容模糊匹配，找到最合适的 step_id，如果无法确定，就向用户确认。
- 如果用户只是提出疑问（例如“这个任务还有几步没完成？”），你可以只给出自然语言回答，不调用任何工具。

输出流程：
1. 如果需要修改：先调用工具（如 update_steps），再在工具调用返回之后给出最终的自然语言回答。
2. 如果不需要修改：直接给出自然语言回答即可。
`

// PlannerAgent 的系统 Prompt
const PlannerSystemPrompt = `
你是一个任务规划助手（Planner Agent）。

你收到的是：
- 当前任务的结构化信息（task 和 steps）
- 当前时间 now（ISO 8601 字符串）
- 用户的最新请求，通常包含“重新规划”“拆解”“重排”“延期后重新安排”等意图

你的职责：
1. 针对当前任务进行结构性的调整，包括但不限于：
   - 重新拆分某一步为多个更细的子步骤
   - 新增或删除步骤
   - 调整步骤的执行顺序（order_index）
   - 根据任务的新截止时间 / 当前进度，重新规划步骤的 planned_start / planned_end
   - 按用户描述创建任务依赖关系（例如“任务A完成后再开始任务B的第一步”）
2. 所有结构性变更必须通过 tools 实现：
   - add_steps：新增步骤或子步骤
   - update_steps：修改步骤标题、描述、顺序、估时、状态、计划时间
   - update_task：更新任务的整体信息（如 due_at、priority）
   - add_dependencies：在任务或步骤之间创建依赖关系
3. 合理地使用 estimate_minutes 和时间窗口：
   - 如果用户给出了明确时间，你要尽量遵循
   - 如果用户只给出“这周内”“今晚”等模糊描述，你可以根据 now 和 due_at 进行合理推断

输出要求：
1. 优先确保工具调用正确、参数齐全，不要出现多余字段。
2. 工具调用完成后，用一段简洁自然语言告诉用户：
   - 新的步骤结构是什么（可以简要列出）
   - 大致执行顺序和时间安排
   - 如果有依赖关系，也要提一下「某任务完成后会自动解锁 XXX 步骤」。

安全与约束：
- 只修改与当前任务真正相关的内容，不要随意创建额外任务。
- 对于非常模糊的描述，如果你不确定具体怎么拆分，先做一版合理的初稿，并在自然语言回复里提醒用户可以继续调整。
`
```

---

## 3. “拼接当前任务 JSON”的示例函数

我们用你之前定义的：

```go
// internal/llm/client.go
type Message struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}
```

### 3.1 构造 ExecutorAgent 的 messages

`internal/agent/prompt_builder.go`：

```go
package agent

import (
	"encoding/json"
	"fmt"
	"time"

	"your-module-name/internal/llm"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

// 将内部的对话消息转换为 LLM 消息（简单版：只保留 role+content）
func historyToLLMMessages(history []session.Message) []llm.Message {
	msgs := make([]llm.Message, 0, len(history))
	for _, m := range history {
		role := m.Role
		// 确保只出现 user/assistant/system 三种
		if role != "user" && role != "assistant" && role != "system" {
			continue
		}
		msgs = append(msgs, llm.Message{
			Role:    role,
			Content: m.Content,
		})
	}
	return msgs
}

// 构造 ExecutorAgent 的 messages：
// - system: ExecutorSystemPrompt
// - system: 当前任务 JSON
// - system: 当前时间
// - 历史消息（可选）
// - user: 最新输入
func BuildExecutorMessages(t *task.Task, history []session.Message, userInput string, now time.Time) ([]llm.Message, error) {
	taskJSON, err := json.Marshal(t)
	if err != nil {
		return nil, err
	}

	msgs := []llm.Message{
		{
			Role:    "system",
			Content: ExecutorSystemPrompt,
		},
		{
			Role: "system",
			Content: fmt.Sprintf(
				"当前任务状态（JSON，只读）：\n%s",
				taskJSON,
			),
		},
		{
			Role:    "system",
			Content: fmt.Sprintf("当前时间 now: %s", now.Format(time.RFC3339)),
		},
	}

	// 历史消息
	msgs = append(msgs, historyToLLMMessages(history)...)

	// 最新用户消息
	msgs = append(msgs, llm.Message{
		Role:    "user",
		Content: userInput,
	})

	return msgs, nil
}
```

### 3.2 构造 PlannerAgent 的 messages

和 Executor 非常类似，只是换了 Prompt 和内容说明。

```go
// BuildPlannerMessages 构造 PlannerAgent 的 messages。
// 这里同样包含：系统提示词 + 当前任务 JSON + 当前时间 + 历史 + 最新 user。
func BuildPlannerMessages(t *task.Task, history []session.Message, userInput string, now time.Time) ([]llm.Message, error) {
	taskJSON, err := json.Marshal(t)
	if err != nil {
		return nil, err
	}

	msgs := []llm.Message{
		{
			Role:    "system",
			Content: PlannerSystemPrompt,
		},
		{
			Role: "system",
			Content: fmt.Sprintf(
				"当前任务结构（JSON，只读）：\n%s",
				taskJSON,
			),
		},
		{
			Role:    "system",
			Content: fmt.Sprintf("当前时间 now: %s", now.Format(time.RFC3339)),
		},
	}

	msgs = append(msgs, historyToLLMMessages(history)...)

	msgs = append(msgs, llm.Message{
		Role:    "user",
		Content: userInput,
	})

	return msgs, nil
}
```

### 3.3 在 Agent.Handle 中的使用示例（伪代码）

在 `ExecutorAgent.Handle` 里，大概是这样用：

```go
// internal/agent/executor_agent.go
package agent

import (
	"context"
	"time"

	"your-module-name/internal/llm"
	"your-module-name/internal/session"
	"your-module-name/internal/task"
)

type ExecutorAgent struct {
	llmClient llm.Client
}

func NewExecutorAgent(llmClient llm.Client) *ExecutorAgent {
	return &ExecutorAgent{llmClient: llmClient}
}

func (a *ExecutorAgent) Name() string { return "executor" }

func (a *ExecutorAgent) Handle(req AgentRequest) (*AgentResponse, error) {
	// 构造 messages
	msgs, err := BuildExecutorMessages(req.Task, req.Messages, req.UserInput, req.Now)
	if err != nil {
		return nil, err
	}

	chatReq := llm.ChatRequest{
		Model:    req.LLMConfig.Model,
		Messages: msgs,
		Tools:    llm.ExecutorTools(), // 只传 Executor 用到的 tools
		// ToolChoice: "auto" 等，根据你在 llm 包里如何定义
	}

	ctx := context.Background() // 或 req.Context
	resp, err := a.llmClient.Chat(ctx, req.LLMConfig, chatReq)
	if err != nil {
		return nil, err
	}

	// TODO:
	// 1. 从 resp 中解析 tool_calls，转换为 TaskPatch 列表，用于后续 applyTaskPatches。
	// 2. 再次喂入 tool 结果，让 LLM 生成最终 AssistantMessage。
	// 这里先返回一个空骨架，让你自己按实际 LLM 响应结构来填。

	return &AgentResponse{
		AssistantMessage: "TODO: parse from LLM response",
		TaskPatches:      nil,
	}, nil
}
```

PlannerAgent 同理，把 `BuildExecutorMessages` 换成 `BuildPlannerMessages`，tools 换成 `llm.PlannerTools()`。

---

这样你就有了：

* **tools 的 Go struct + 常用 tools 列表构造**
* **Executor / Planner 的系统 prompt 常量**
* **把Task结构序列化为 JSON 并拼进 LLM messages 的示例函数**

剩下的关键工作就是：

* 根据你实际用的 OpenAI-Compatible 服务的返回格式，写一段工具调用结果解析逻辑（把 tool_calls → TaskPatch → DB 更新）。
* 在 `AgentService.applyTaskPatches` 里把 `TaskPatch` 落到 MySQL。

如果你想，我也可以帮你设计一套 `TaskPatch` 的 Go struct + 从 tool 调用 arguments 映射到 `TaskPatch` 的示例代码。
