下面给你两页的样板代码：

* `CreateFromTextPage`：粘贴文本 → 调后端 `/tasks/from-text` → 跳转到 `/tasks/:id`
* `GlobalAssistantPage`：一个“我今天要做什么？”的全局聊天页，用同一个 `ChatWindow` 组件

我会顺带把需要的新 API 函数也写出来，你可以直接放到对应文件里用。

---

## 1. API：从文本创建任务 & 全局会话

### 1.1 `src/api/tasks.ts` 补充 `createTaskFromText`

```ts
// src/api/tasks.ts
import apiClient from './client';
import type { TaskDetailResponse } from '@/types';

export async function fetchTaskDetail(taskId: string | number): Promise<TaskDetailResponse> {
  const { data } = await apiClient.get<TaskDetailResponse>(`/tasks/${taskId}`);
  return data;
}

// 新增：从文本创建任务
export async function createTaskFromText(rawText: string): Promise<TaskDetailResponse> {
  const { data } = await apiClient.post<TaskDetailResponse>('/tasks/from-text', {
    raw_text: rawText,
  });
  return data;
}
```

> 注意：`raw_text` 字段名要和你后端 handler 对齐。

### 1.2 `src/api/sessions.ts` 补充全局会话相关

这里假设后端有两个接口（你可以按需改）：

* `GET /sessions/global`：返回当前用户的 global session（不存在就创建再返回）
* `GET /sessions/:id/messages`：获取消息列表
* `POST /sessions/:id/messages`：发送消息

```ts
// src/api/sessions.ts
import apiClient from './client';
import type {
  Session,
  SessionMessagesResponse,
  SendMessageResponse,
} from '@/types';

// 已有
export async function fetchSessionMessages(
  sessionId: number | string,
): Promise<SessionMessagesResponse> {
  const { data } = await apiClient.get<SessionMessagesResponse>(`/sessions/${sessionId}/messages`);
  return data;
}

export async function sendSessionMessage(
  sessionId: number | string,
  content: string,
): Promise<SendMessageResponse> {
  const { data } = await apiClient.post<SendMessageResponse>(
    `/sessions/${sessionId}/messages`,
    { content },
  );
  return data;
}

// 新增：获取或创建当前用户的全局会话
export async function getOrCreateGlobalSession(): Promise<Session> {
  const { data } = await apiClient.get<Session>('/sessions/global');
  return data;
}
```

> 如果你希望 `GET /sessions/global` 返回 `{ session: Session }`，就把返回类型稍微改一下。

---

## 2. CreateFromTextPage

路径示例：`src/pages/Tasks/CreateFromTextPage.tsx`

### 2.1 组件代码

```tsx
// src/pages/Tasks/CreateFromTextPage.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMutation } from '@tanstack/react-query';
import { Button, Card, Form, Input, Space, Typography, message as antdMessage } from 'antd';

import { createTaskFromText } from '@/api/tasks';

const { TextArea } = Input;
const { Title, Text, Paragraph } = Typography;

export const CreateFromTextPage: React.FC = () => {
  const navigate = useNavigate();
  const [form] = Form.useForm();
  const [length, setLength] = useState(0);

  const createMutation = useMutation({
    mutationFn: (rawText: string) => createTaskFromText(rawText),
    onSuccess: (data) => {
      antdMessage.success('已根据文本生成任务');
      // 假设后端返回 { task: Task, session: Session }
      const taskId = data.task.id;
      navigate(`/tasks/${taskId}`);
    },
    onError: (err: any) => {
      console.error(err);
      antdMessage.error('生成任务失败，请稍后重试');
    },
  });

  const handleSubmit = async (values: { rawText: string }) => {
    const rawText = values.rawText?.trim();
    if (!rawText) {
      antdMessage.warning('请输入一些内容');
      return;
    }
    await createMutation.mutateAsync(rawText);
  };

  return (
    <div style={{ padding: 24, display: 'flex', justifyContent: 'center' }}>
      <Card style={{ maxWidth: 800, width: '100%' }}>
        <Space direction="vertical" style={{ width: '100%' }} size="large">
          <div>
            <Title level={3} style={{ marginBottom: 8 }}>
              从文本创建任务
            </Title>
            <Paragraph type="secondary">
              你可以直接粘贴会议记录、聊天记录或备忘录，系统会自动帮你生成一个任务，并拆解为多个步骤。
            </Paragraph>
          </div>

          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmit}
          >
            <Form.Item
              label={
                <Space>
                  <span>原始文本</span>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    （当前字数：{length}）
                  </Text>
                </Space>
              }
              name="rawText"
              rules={[{ required: true, message: '请粘贴或输入文本' }]}
            >
              <TextArea
                rows={12}
                placeholder="例如：本周需要完成 AIGC 小论文，周一前看 10 篇文章..."
                onChange={(e) => setLength(e.target.value.length)}
                disabled={createMutation.isPending}
              />
            </Form.Item>

            <Form.Item style={{ textAlign: 'right' }}>
              <Space>
                <Button onClick={() => form.resetFields()} disabled={createMutation.isPending}>
                  清空
                </Button>
                <Button
                  type="primary"
                  htmlType="submit"
                  loading={createMutation.isPending}
                >
                  生成任务
                </Button>
              </Space>
            </Form.Item>
          </Form>
        </Space>
      </Card>
    </div>
  );
};
```

### 2.2 路由挂载

在你的 `router.tsx` 里加一条路由，例如：

```tsx
// router.tsx 片段
import { CreateFromTextPage } from '@/pages/Tasks/CreateFromTextPage';
import { TaskDetailPage } from '@/pages/Tasks/TaskDetailPage';

// ...
<Route path="/tasks/new-from-text" element={<CreateFromTextPage />} />
<Route path="/tasks/:taskId" element={<TaskDetailPage />} />
```

---

## 3. GlobalAssistantPage（“我今天要做什么？”）

路径示例：`src/pages/Global/GlobalAssistantPage.tsx`

### 3.1 组件代码

```tsx
// src/pages/Global/GlobalAssistantPage.tsx
import React, { useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, Button, Space, Spin, Typography, message as antdMessage } from 'antd';
import { BulbOutlined, ReloadOutlined } from '@ant-design/icons';

import { ChatWindow } from '@/components/chat/ChatWindow';
import { getOrCreateGlobalSession, fetchSessionMessages, sendSessionMessage } from '@/api/sessions';
import type { Message } from '@/types';

const { Title, Text, Paragraph } = Typography;

export const GlobalAssistantPage: React.FC = () => {
  const queryClient = useQueryClient();

  // 1. 获取/创建 global session
  const {
    data: session,
    isLoading: loadingSession,
    isError: sessionError,
    refetch: refetchSession,
  } = useQuery({
    queryKey: ['globalSession'],
    queryFn: () => getOrCreateGlobalSession(),
  });

  const sessionId = session?.id;

  // 2. 拉取消息
  const {
    data: messagesData,
    isLoading: loadingMessages,
    refetch: refetchMessages,
  } = useQuery({
    queryKey: ['sessionMessages', sessionId],
    queryFn: () => fetchSessionMessages(sessionId!),
    enabled: !!sessionId,
  });

  const messages: Message[] = messagesData?.messages ?? [];

  // 3. 发送消息
  const sendMutation = useMutation({
    mutationFn: (content: string) => sendSessionMessage(sessionId!, content),
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ['sessionMessages', sessionId] });
    },
    onError: (err: any) => {
      console.error(err);
      antdMessage.error('发送失败，请稍后重试');
    },
  });

  const handleQuickAskToday = async () => {
    if (!sessionId) return;
    await sendMutation.mutateAsync('我今天要做什么？');
  };

  useEffect(() => {
    if (sessionError) {
      antdMessage.error('获取全局会话失败，请稍后重试');
    }
  }, [sessionError]);

  if (loadingSession) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <Spin />
      </div>
    );
  }

  if (!session) {
    return (
      <div style={{ padding: 24 }}>
        <Text type="danger">无法初始化全局会话</Text>
      </div>
    );
  }

  return (
    <div style={{ padding: 24, display: 'flex', justifyContent: 'center' }}>
      <Card style={{ maxWidth: 1000, width: '100%' }}>
        <Space direction="vertical" style={{ width: '100%' }} size="large">
          <div>
            <Space align="center">
              <BulbOutlined style={{ fontSize: 24, color: '#faad14' }} />
              <Title level={3} style={{ margin: 0 }}>
                全局助手
              </Title>
            </Space>
            <Paragraph type="secondary" style={{ marginTop: 8 }}>
              这里可以问一些跨任务的问题，例如：
              <br />
              「我今天要做什么？」、「帮我看看这周安排」、「有没有已经过期的任务？」等。
            </Paragraph>
          </div>

          <Space style={{ justifyContent: 'space-between', width: '100%' }}>
            <Space>
              <Button
                icon={<BulbOutlined />}
                onClick={handleQuickAskToday}
                disabled={sendMutation.isPending || !sessionId}
              >
                我今天要做什么？
              </Button>
            </Space>
            <Space>
              <Button
                icon={<ReloadOutlined />}
                onClick={() => {
                  void refetchMessages();
                }}
                disabled={loadingMessages}
              >
                刷新
              </Button>
            </Space>
          </Space>

          <ChatWindow
            messages={messages}
            onSend={(content) => sendMutation.mutateAsync(content)}
            sending={sendMutation.isPending}
            height={520}
          />
        </Space>
      </Card>
    </div>
  );
};
```

### 3.2 路由挂载

```tsx
// router.tsx 片段
import { GlobalAssistantPage } from '@/pages/Global/GlobalAssistantPage';

// ...
<Route path="/assistant" element={<GlobalAssistantPage />} />
```

---

## 4. 小结一下你需要对齐的后端接口

前端这两页默认假设后端有以下路由（你可以根据自己最终的 API 改一下路径/返回类型）：

* `POST /api/tasks/from-text`

  * 请求：`{ raw_text: string }`
  * 响应：`{ task: Task, session: Session }`
* `GET /api/tasks/:id`

  * 响应：`{ task: Task, session: Session }`
* `GET /api/sessions/global`

  * 响应：`Session`
* `GET /api/sessions/:id/messages`

  * 响应：`{ messages: Message[] }`
* `POST /api/sessions/:id/messages`

  * 请求：`{ content: string }`
  * 响应：`{ assistant_message: string, task_patches?: any }`（前端目前只用到文案）

只要后端返回的数据结构按你之前的 TS 类型定义来，就可以直接跑通一个从：

* 登录 →
* 粘贴文本创建任务 →
* 查看任务详情 + Agent 对话 →
* 在全局助手问“我今天要做什么？”

的端到端流程。

如果你想，下一步我可以帮你把这几个后端路由的 JSON response 结构再精细揣摩一下，给一份「后端-前端对齐的 API 协议文档」。
