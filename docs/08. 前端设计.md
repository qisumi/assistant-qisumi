## 三、前端架构设计（React + TS + PWA）

结合你现在的后端设计，我建议前端这套架构：

### 3.1 技术栈

* 构建：**Vite + React + TypeScript**
* 路由：**React Router v6**
* 数据请求 & 缓存：**TanStack Query（react-query）**
* 全局状态（用户/LLM 配置）：**Zustand**（或者直接用 React Context）
* UI：任意组件库（比如 Ant Design / MUI / Radix+Tailwind，看你喜好）
* PWA：

  * `manifest.json`
  * 简单的 Service Worker（静态资源缓存）

### 3.2 目录结构建议

```text
src/
  main.tsx
  router.tsx

  api/
    client.ts          // 封装 fetch/axios + JWT header
    auth.ts
    tasks.ts
    sessions.ts
    llmSettings.ts

  pages/
    Auth/
      LoginPage.tsx
      RegisterPage.tsx
    Tasks/
      TaskListPage.tsx
      TaskDetailPage.tsx
      CreateFromTextPage.tsx
    Settings/
      LLMSettingsPage.tsx
    Global/
      GlobalAssistantPage.tsx

  components/
    layout/
      AppLayout.tsx
      Header.tsx
      Sidebar.tsx
    tasks/
      TaskCard.tsx
      TaskStepList.tsx
      TaskMetaPanel.tsx
    chat/
      ChatWindow.tsx
      MessageBubble.tsx
      MessageInput.tsx
    common/
      Loading.tsx
      ErrorBoundary.tsx

  store/
    authStore.ts        // JWT、当前用户
    llmConfigStore.ts   // LLM base_url / model（如果需要前端持有）
    uiStore.ts          // 一些 UI 状态（可选）

  hooks/
    useAuth.ts
    useTasks.ts
    useTaskDetail.ts
    useSessionChat.ts

  types/
    task.ts
    session.ts
    user.ts
    llm.ts

  pwa/
    service-worker.ts
    manifest.json

  styles/
    index.css
```

### 3.3 与后端的对应关系

#### API 层（`src/api`）

* `client.ts`：

  * 封装一个 `request` 方法（基于 fetch 或 axios）
  * 自动从 `authStore` 里拿 JWT，加 `Authorization: Bearer <token>`
  * 统一处理 401（跳转登录）

* `auth.ts`：

  * `login(email, password) -> token`
  * `register(email, password)`

* `tasks.ts`：

  * `getTasks(params)` → `/api/tasks`
  * `getTaskDetail(id)` → `/api/tasks/:id`
  * `createTaskFromText(rawText)` → `/api/tasks/from-text`

* `sessions.ts`：

  * `createTaskSession(taskId)`（如果你在前端需要显式创建）
  * `getSessionMessages(sessionId)`
  * `sendSessionMessage(sessionId, content)` → `/api/sessions/:id/messages`

* `llmSettings.ts`：

  * `getUserLLMSettings()` / `updateUserLLMSettings()`（后端读写 `user_llm_settings`）

#### 状态管理

* `authStore.ts`：

  * 存 JWT + 当前用户基本信息
  * 提供 `login` / `logout` 方法

* `llmConfigStore.ts`（可选）：

  * 是否在前端也保存一份 LLM 配置？

    * 如果后端统一从 DB 拿，那前端只需要一个“配置页面”做表单即可；
    * 你也可以在前端 store 里缓存一下，方便页面显示。

#### 页面角色

1. **LoginPage / RegisterPage**

   * 表单 + 调用 `auth.login` / `auth.register`
   * 登录成功后接收 token，写入 `authStore`，跳转 `/tasks`

2. **TaskListPage**

   * 使用 react-query：`useQuery(["tasks"], getTasks)`
   * 显示任务卡片：标题、截止时间、进度等
   * 支持简单过滤（进行中/已完成/过期）

3. **TaskDetailPage**

   * 路由 `/tasks/:id`
   * 上半部分：任务信息 + 步骤列表（`TaskMetaPanel` + `TaskStepList`）
   * 下半部分：聊天窗口 `ChatWindow`
   * 数据：

     * `useTaskDetail(id)` 内部拉 `/tasks/:id` + `/sessions?task_id=:id`（或由后端返回 sessionId）
     * `useSessionChat(sessionId)` 管理消息列表 + 发送消息 mutation

4. **CreateFromTextPage**

   * 文本域 + 提交按钮
   * `onSubmit` → `createTaskFromText(rawText)`
   * 后端返回 task + sessionId 后，跳转 `/tasks/:id`

5. **LLMSettingsPage**

   * 表单 + `useQuery` 拉当前 `user_llm_settings`
   * `onSave` 调 `updateUserLLMSettings`
   * 后端加密保存 API key，不在前端存明文（你也可以让用户每次打开看不到 key，只能重置）

6. **GlobalAssistantPage**

   * 一个全局 Chat 窗口
   * 后端使用 `type='global'` 的 session
   * 用户问「我今天要做什么？」，后端 GlobalAgent 返回总结
   * 前端只负责显示 messages（含角色/agent_name 标签）

#### Chat UI（`ChatWindow`）

* props：

  * `messages: Message[]`
  * `onSend: (content: string) => Promise<void>`
* 渲染：

  * 根据 `role` + `agent_name` 决定气泡样式：

    * user：右对齐
    * assistant：左对齐，显示 agent tag（executor/planner/global 等）
    * system：灰色细字体，类似系统提示
* 发送消息流程：

  1. 用户输入 → 调 `onSend`
  2. 本地可以先插一条“optimistic” user 消息
  3. `onSend` 内调 `POST /sessions/:id/messages`
  4. 成功后刷一次消息列表（或直接 concat assistant 回复）

### 3.4 PWA 部分

* `manifest.json`：

  * `name`、`short_name`、`icons`、`start_url`、`display: "standalone"`、`theme_color` 等
* `service-worker.ts`：

  * 用 Workbox 或手写：

    * `install`：缓存 `/index.html`、JS/CSS bundle、图标
    * `fetch`：优先网络，失败再读 cache
  * 不建议一开始就实现离线数据编辑；先实现“离线也能打开 UI，提醒无法同步”即可

### 3.5 多 Agent 对前端的表现

* 前端不需要关心具体是哪个 Agent 在工作（Planner/Executor/Global），只要：

  * 在 `messages` 返回结构中包含 `agent_name`（后端已经设计了）
  * `MessageBubble` 根据 `agent_name` 决定一个小 Tag：

    * executor → “执行”
    * planner → “规划”
    * global → “全局”
    * summarizer → “总结”
* 对用户来说，这样可以看到“现在是谁在回答”，但逻辑完全在后端 Orchestrator 实现，前端保持简单。

---

## 总结你现在可以做的下一步

1. **后端**

   * 替换成 GORM 初始化（`NewGormDB`）+ `AutoMigrate`
   * 把仓库改成用 `*gorm.DB`（我们已经给了 Task / Session / Dependency 的示例）
   * 在依赖触发中用 `CreateSystemMessageForTask` 写系统提示

2. **前端**

   * 用 Vite + React + TS 跑起来基础工程
   * 搭好 `router.tsx` 和 `AppLayout`
   * 先做登录 + TaskList + TaskDetail 三个页面，后面再加 GlobalAssistant / Settings