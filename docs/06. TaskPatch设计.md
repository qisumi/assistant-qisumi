太好了，这块正好适合用 GORM 做得干干净净，我直接给你：

1. 用 GORM 重写 `Task` / `TaskStep` / `TaskDependency` 模型
2. `ApplyUpdateTaskFields` / `ApplyUpdateStepFields` 基于 **指针字段 + map 更新** 的动态 UPDATE 写法
3. 一个简化版 `DependencyService.OnTaskOrStepDone` 的实现（用 GORM 查询 `task_dependencies`，然后解锁后续步骤）

你可以直接复制到工程里用，按需改包名。

---

## 一、GORM 模型定义

假设放在 `internal/task/models_gorm.go` 和 `internal/dependency/models_gorm.go`。

### 1.1 Task / TaskStep（GORM）

```go
package task

import (
	"time"
)

type Task struct {
	ID          uint64     `gorm:"primaryKey;column:id"`
	UserID      uint64     `gorm:"column:user_id;not null"`
	Title       string     `gorm:"column:title;type:varchar(255);not null"`
	Description string     `gorm:"column:description;type:text"`
	Status      string     `gorm:"column:status;type:enum('todo','in_progress','done','cancelled');not null;default:'todo'"`
	Priority    string     `gorm:"column:priority;type:enum('low','medium','high');default:'medium'"`
	DueAt       *time.Time `gorm:"column:due_at"`
	CreatedFrom string     `gorm:"column:created_from;type:text"`
	CreatedAt   time.Time  `gorm:"column:created_at;autoCreateTime"`
	UpdatedAt   time.Time  `gorm:"column:updated_at;autoUpdateTime"`

	Steps []TaskStep `gorm:"foreignKey:TaskID"`
}

func (Task) TableName() string { return "tasks" }

type TaskStep struct {
	ID             uint64     `gorm:"primaryKey;column:id"`
	TaskID         uint64     `gorm:"column:task_id;not null"`
	OrderIndex     int        `gorm:"column:order_index;not null;default:0"`
	Title          string     `gorm:"column:title;type:varchar(255);not null"`
	Detail         string     `gorm:"column:detail;type:text"`
	Status         string     `gorm:"column:status;type:enum('locked','todo','in_progress','done','blocked');not null;default:'todo'"`
	BlockingReason string     `gorm:"column:blocking_reason;type:text"`
	EstimateMin    *int       `gorm:"column:estimate_minutes"`
	PlannedStart   *time.Time `gorm:"column:planned_start"`
	PlannedEnd     *time.Time `gorm:"column:planned_end"`
	CreatedAt      time.Time  `gorm:"column:created_at;autoCreateTime"`
	UpdatedAt      time.Time  `gorm:"column:updated_at;autoUpdateTime"`
}

func (TaskStep) TableName() string { return "task_steps" }
```

> 如果你后面需要 parent_step_id（子任务），再加字段即可。

### 1.2 TaskDependency（GORM）

```go
package dependency

import "time"

type TaskDependency struct {
	ID uint64 `gorm:"primaryKey;column:id"`

	PredecessorTaskID uint64  `gorm:"column:predecessor_task_id;not null"`
	PredecessorStepID *uint64 `gorm:"column:predecessor_step_id"`
	SuccessorTaskID   uint64  `gorm:"column:successor_task_id;not null"`
	SuccessorStepID   *uint64 `gorm:"column:successor_step_id"`

	Condition string    `gorm:"column:condition;type:enum('task_done','step_done');not null"`
	Action    string    `gorm:"column:action;type:enum('unlock_step','set_task_todo','notify_only');not null;default:'unlock_step'"`
	CreatedAt time.Time `gorm:"column:created_at;autoCreateTime"`
}

func (TaskDependency) TableName() string { return "task_dependencies" }
```

---

## 二、动态 UPDATE：ApplyUpdateTaskFields / ApplyUpdateStepFields（GORM）

你之前定义的 `UpdateTaskFields` / `UpdateStepFields` 已经是**指针字段**，非常适合做「部分更新」——只要哪个字段不为 nil，就往 `map[string]any` 里塞对应字段即可。

### 2.1 复用的字段结构（回顾）

```go
package agent

type UpdateTaskFields struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`   // "todo" | "in_progress" | "done" | "cancelled"
	Priority    *string `json:"priority,omitempty"` // "low" | "medium" | "high"
	DueAt       *string `json:"due_at,omitempty"`   // ISO 8601
}

type UpdateStepFields struct {
	Title          *string `json:"title,omitempty"`
	Detail         *string `json:"detail,omitempty"`
	Status         *string `json:"status,omitempty"`
	BlockingReason *string `json:"blocking_reason,omitempty"`
	EstimateMin    *int    `json:"estimate_minutes,omitempty"`
	OrderIndex     *int    `json:"order_index,omitempty"`
	PlannedStart   *string `json:"planned_start,omitempty"` // ISO 8601
	PlannedEnd     *string `json:"planned_end,omitempty"`   // ISO 8601
}
```

### 2.2 构造 update map 的帮助函数

可以放在 `internal/task/repo_gorm.go` 或单独一个 util 文件：

```go
package task

import (
	"time"

	"your-module-name/internal/agent"
)

// 把 UpdateTaskFields 转成 GORM Updates 使用的 map
func buildTaskUpdateMap(fields agent.UpdateTaskFields) (map[string]any, error) {
	updates := make(map[string]any)

	if fields.Title != nil {
		updates["title"] = *fields.Title
	}
	if fields.Description != nil {
		updates["description"] = *fields.Description
	}
	if fields.Status != nil {
		updates["status"] = *fields.Status
	}
	if fields.Priority != nil {
		updates["priority"] = *fields.Priority
	}
	if fields.DueAt != nil {
		if *fields.DueAt == "" {
			// 空字符串表示清空 due_at
			updates["due_at"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.DueAt)
			if err != nil {
				return nil, err
			}
			updates["due_at"] = t
		}
	}

	return updates, nil
}

func buildStepUpdateMap(fields agent.UpdateStepFields) (map[string]any, error) {
	updates := make(map[string]any)

	if fields.Title != nil {
		updates["title"] = *fields.Title
	}
	if fields.Detail != nil {
		updates["detail"] = *fields.Detail
	}
	if fields.Status != nil {
		updates["status"] = *fields.Status
	}
	if fields.BlockingReason != nil {
		updates["blocking_reason"] = *fields.BlockingReason
	}
	if fields.EstimateMin != nil {
		updates["estimate_minutes"] = *fields.EstimateMin
	}
	if fields.OrderIndex != nil {
		updates["order_index"] = *fields.OrderIndex
	}
	if fields.PlannedStart != nil {
		if *fields.PlannedStart == "" {
			updates["planned_start"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.PlannedStart)
			if err != nil {
				return nil, err
			}
			updates["planned_start"] = t
		}
	}
	if fields.PlannedEnd != nil {
		if *fields.PlannedEnd == "" {
			updates["planned_end"] = nil
		} else {
			t, err := time.Parse(time.RFC3339, *fields.PlannedEnd)
			if err != nil {
				return nil, err
			}
			updates["planned_end"] = t
		}
	}

	return updates, nil
}
```

> 这里对空字符串的处理：我用了“空字符串 = 清空该时间字段”的约定，你可以根据自己业务调整。

### 2.3 Repository 使用 GORM 的动态更新

Repository 改写成基于 `*gorm.DB`：

```go
package task

import (
	"context"

	"gorm.io/gorm"
	"your-module-name/internal/agent"
)

type Repository struct {
	db *gorm.DB
}

func NewRepository(db *gorm.DB) *Repository {
	return &Repository{db: db}
}

// 可选：支持在事务中生成一个带 Tx 的 repo
func (r *Repository) WithTx(tx *gorm.DB) *Repository {
	return &Repository{db: tx}
}

// 动态更新 tasks
func (r *Repository) ApplyUpdateTaskFields(
	ctx context.Context,
	userID, taskID uint64,
	fields agent.UpdateTaskFields,
) error {
	updates, err := buildTaskUpdateMap(fields)
	if err != nil {
		return err
	}
	if len(updates) == 0 {
		return nil
	}

	return r.db.WithContext(ctx).
		Model(&Task{}).
		Where("id = ? AND user_id = ?", taskID, userID).
		Updates(updates).Error
}

// 动态更新 task_steps 中的一行
func (r *Repository) ApplyUpdateStepFields(
	ctx context.Context,
	userID, taskID, stepID uint64,
	fields agent.UpdateStepFields,
) error {
	updates, err := buildStepUpdateMap(fields)
	if err != nil {
		return err
	}
	if len(updates) == 0 {
		return nil
	}

	// 加上 user_id 保护：可以通过 JOIN 或子查询限制
	// 这里为了简单，用子查询判断该 step 属于该用户的 task
	subQuery := r.db.
		Select("id").
		Table("tasks").
		Where("id = ? AND user_id = ?", taskID, userID)

	return r.db.WithContext(ctx).
		Model(&TaskStep{}).
		Where("id = ? AND task_id IN (?)", stepID, subQuery).
		Updates(updates).Error
}
```

> 这里用了 `subQuery` 保证步子确实属于当前用户的任务，避免越权；你也可以先查一遍 Task 再更新步。

---

## 三、简化版 DependencyService.OnTaskOrStepDone（GORM）

目标：当某个任务/步骤状态变为 `done`，查 `task_dependencies`，自动：

* 解锁后续步骤（从 `locked` → `todo`）
* 或把后续任务状态设为 `todo`/`in_progress`
* 或只记一条系统消息（这里先简单略过）

### 3.1 Service 定义

放在 `internal/dependency/service.go`：

```go
package dependency

import (
	"context"

	"gorm.io/gorm"
	"your-module-name/internal/task"
)

type Service struct {
	db       *gorm.DB
	taskRepo *task.Repository
}

func NewService(db *gorm.DB, taskRepo *task.Repository) *Service {
	return &Service{
		db:       db,
		taskRepo: taskRepo,
	}
}
```

### 3.2 OnTaskOrStepDone 实现

假设签名为：

```go
// predecessorStepID 为 nil 表示「整个任务完成」的触发
func (s *Service) OnTaskOrStepDone(
	ctx context.Context,
	predecessorTaskID uint64,
	predecessorStepID *uint64,
) error
```

实现：

```go
func (s *Service) OnTaskOrStepDone(
	ctx context.Context,
	predecessorTaskID uint64,
	predecessorStepID *uint64,
) error {
	return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		var deps []TaskDependency

		q := tx.Where("predecessor_task_id = ?", predecessorTaskID)
		if predecessorStepID != nil {
			q = q.Where("predecessor_step_id = ?", *predecessorStepID).
				Where("condition = ?", "step_done")
		} else {
			// 任务完成触发：predecessor_step_id IS NULL AND condition = 'task_done'
			q = q.Where("predecessor_step_id IS NULL").
				Where("condition = ?", "task_done")
		}

		if err := q.Find(&deps).Error; err != nil {
			return err
		}
		if len(deps) == 0 {
			return nil
		}

		// 针对每条依赖执行对应动作
		for _, d := range deps {
			switch d.Action {
			case "unlock_step":
				if d.SuccessorStepID == nil {
					// 没有具体步骤就跳过
					continue
				}
				// 仅在 locked 状态下改为 todo，避免覆盖用户手动状态
				if err := tx.Model(&task.TaskStep{}).
					Where("id = ? AND task_id = ? AND status = ?", *d.SuccessorStepID, d.SuccessorTaskID, "locked").
					Update("status", "todo").Error; err != nil {
					return err
				}

			case "set_task_todo":
				// 如果任务不是 done，就把状态设置为 todo（或 in_progress，按你业务来）
				if err := tx.Model(&task.Task{}).
					Where("id = ? AND status != ?", d.SuccessorTaskID, "done").
					Update("status", "todo").Error; err != nil {
					return err
				}

			case "notify_only":
				// 简化版：你可以在这里写一条 system message 到该任务的 session
				// 这里先留个 TODO
				// TODO: 写入系统消息，例如 "前置任务 X 完成，后续任务 Y 已准备好。"
			}
		}

		return nil
	})
}
```

> 注意：
>
> * 这里用 `Transaction` 保证依赖操作是一致的
> * 解锁步骤时加了 `status = 'locked'` 条件，避免覆盖用户已经“手工标为 done/in_progress”的情况
> * 如果你要触发更多逻辑（例如发通知），建议通过事件或回调来做

### 3.3 在业务里调用 OnTaskOrStepDone

当你更新任务/步骤状态时（例如在 `ApplyUpdateTaskFields` / `ApplyUpdateStepFields` 的上层 service）：

```go
// 伪代码示意

// 更新 step 状态
if err := taskRepo.ApplyUpdateStepFields(ctx, userID, taskID, stepID, fields); err != nil {
    return err
}

// 如果 status 被设为 done，则触发依赖服务
if fields.Status != nil && *fields.Status == "done" {
    if err := dependencySvc.OnTaskOrStepDone(ctx, taskID, &stepID); err != nil {
        return err
    }
}
```

任务完成同理，只是 `predecessorStepID = nil`。