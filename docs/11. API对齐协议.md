下面我帮你把目前前后端用到的主要接口统一成一份「API 协议文档」，你可以直接当 contract 用来对齐前后端实现。

我会分块写：约定 → 任务相关 → 会话/消息相关 → 全局助手相关 → LLM 设置（可选）→ 错误格式。

---

## 0. 总体约定

### 0.1 基本信息

* API Base URL：`https://your-domain.com/api`
* 所有接口返回 JSON
* 推荐使用 **camelCase** 作为 JSON 字段命名（前端 TS 已按 camelCase 定义）

### 0.2 认证

* 所有需要登录的接口通过请求头传 JWT：

```http
Authorization: Bearer <access_token>
```

* 未认证或 token 无效时返回 `401 Unauthorized`，body 形如：

```json
{
  "error": "unauthorized",
  "message": "invalid or missing token"
}
```

### 0.3 时间字段

* 所有时间字段使用 RFC3339 / ISO 8601 格式字符串，例如：

```json
"2025-12-08T21:30:00Z"
"2025-12-08T21:30:00+08:00"
```

* 字段命名统一为 `xxxAt`：`createdAt`, `updatedAt`, `dueAt`, `plannedStart`, `plannedEnd`。

### 0.4 错误格式统一

建议所有非 2xx 响应统一格式：

```json
{
  "error": "short_code",
  "message": "人类可读错误信息",
  "details": {...}         // 可选，用于携带字段错误等
}
```

例：

```json
{
  "error": "validation_error",
  "message": "raw_text is required"
}
```

---

## 1. Task 相关接口

### 1.1 从文本创建任务

**POST** `/tasks/from-text`

* **说明**：用户粘贴文本，由后端调用 LLM 解析 → 创建 `task + steps + session`
* **认证**：需要
* **请求体：**

```json
{
  "rawText": "本周完成 AIGC 小论文，先看 10 篇文章，然后写开题..."
}
```

> 注意：前端我们之前示例里用了 `raw_text`，建议统一改成 `rawText`（camelCase），后端用 `json:"rawText"` 绑定。

* **成功响应：`200 OK`**

```json
{
  "task": {
    "id": 1,
    "userId": 123,
    "title": "完成 AIGC 小论文",
    "description": "根据你提供的文本自动生成的任务描述...",
    "status": "todo",                 // "todo" | "in_progress" | "done" | "cancelled"
    "priority": "high",              // "low" | "medium" | "high"
    "dueAt": "2025-12-15T23:59:00Z",
    "createdAt": "2025-12-08T10:00:00Z",
    "updatedAt": "2025-12-08T10:00:00Z",
    "steps": [
      {
        "id": 11,
        "taskId": 1,
        "orderIndex": 1,
        "title": "阅读相关文献",
        "detail": "重点阅读 10 篇 AIGC 相关论文，关注方法和实验设计。",
        "status": "todo",             // "locked" | "todo" | "in_progress" | "done" | "blocked"
        "blockingReason": null,
        "estimateMinutes": 240,
        "plannedStart": null,
        "plannedEnd": null,
        "createdAt": "2025-12-08T10:00:00Z",
        "updatedAt": "2025-12-08T10:00:00Z"
      }
      // ...
    ]
  },
  "session": {
    "id": 1001,
    "userId": 123,
    "taskId": 1,
    "type": "task",                   // "task" | "global"
    "createdAt": "2025-12-08T10:00:00Z"
  }
}
```

* **常见错误：**

  * `400 Bad Request`：文本为空或太短
  * `502 Bad Gateway`：调用 LLM 失败（可以在 message 里说明）

---

### 1.2 获取任务详情（含步骤 & 默认会话）

**GET** `/tasks/:id`

* **说明**：前端 `TaskDetailPage` 入口，返回任务基本信息、步骤，以及该任务默认的会话信息（如果没有可以创建一个再返回）。

* **认证**：需要；只能访问自己的任务。

* **成功响应：`200 OK`**

```json
{
  "task": {
    "id": 1,
    "userId": 123,
    "title": "完成 AIGC 小论文",
    "description": "根据你提供的文本自动生成的任务描述...",
    "status": "in_progress",
    "priority": "high",
    "dueAt": "2025-12-15T23:59:00Z",
    "createdAt": "2025-12-08T10:00:00Z",
    "updatedAt": "2025-12-08T12:30:00Z",
    "steps": [
      {
        "id": 11,
        "taskId": 1,
        "orderIndex": 1,
        "title": "阅读相关文献",
        "detail": "重点阅读 10 篇 AIGC 相关论文...",
        "status": "done",
        "blockingReason": null,
        "estimateMinutes": 240,
        "plannedStart": "2025-12-08T09:00:00Z",
        "plannedEnd": "2025-12-08T13:00:00Z",
        "createdAt": "2025-12-08T10:00:00Z",
        "updatedAt": "2025-12-08T11:30:00Z"
      },
      {
        "id": 12,
        "taskId": 1,
        "orderIndex": 2,
        "title": "撰写初稿",
        "detail": "",
        "status": "in_progress",
        "blockingReason": null,
        "estimateMinutes": 300,
        "plannedStart": "2025-12-08T14:00:00Z",
        "plannedEnd": "2025-12-08T19:00:00Z",
        "createdAt": "2025-12-08T10:00:00Z",
        "updatedAt": "2025-12-08T12:00:00Z"
      }
    ]
  },
  "session": {
    "id": 1001,
    "userId": 123,
    "taskId": 1,
    "type": "task",
    "createdAt": "2025-12-08T10:00:00Z"
  }
}
```

> **注意**：这里没有直接返回 `messages` 数组，前端会用 `session.id` 再调用 `/sessions/:id/messages` 获取消息。
> 这样接口职责清晰，也避免初次加载太多历史消息。

* **错误：**

  * `404 Not Found`：任务不存在或不属于当前用户

---

## 2. Session & Message 相关接口

### 2.1 获取当前用户的全局会话（Global Session）

**GET** `/sessions/global`

* **说明**：如果用户没有 global session，则后端创建一条 `type="global", taskId=null` 的 session 再返回。

* **认证**：需要

* **成功响应：`200 OK`**

推荐返回形态：

```json
{
  "session": {
    "id": 2001,
    "userId": 123,
    "taskId": null,
    "type": "global",
    "createdAt": "2025-12-08T09:00:00Z"
  }
}
```

（也可以直接返回 Session 对象，不包外层；但包一层更利于后续扩展）

### 2.2 获取某个会话的消息列表

**GET** `/sessions/:id/messages`

* **说明**：用于任务会话和全局会话，统一查询消息列表。

* **认证**：需要；只能访问属于当前用户的 session（`session.userId == currentUserId`）

* **可选 Query 参数：**

```text
?limit=50&before=2025-12-08T12:00:00Z
```

* `limit`: 默认 50，一次返回多少条
* `before`: 返回这个时间之前的消息（做分页用）

> 第一版可以不做分页，直接返回最近 N 条。

* **成功响应：`200 OK`**

```json
{
  "sessionId": 1001,
  "messages": [
    {
      "id": 5001,
      "sessionId": 1001,
      "role": "system",            // "user" | "assistant" | "system"
      "agentName": "system",       // 可为 null; "executor" | "planner" | ...
      "content": "已为你根据文本创建任务，并拆分为 3 个步骤。",
      "createdAt": "2025-12-08T10:00:00Z"
    },
    {
      "id": 5002,
      "sessionId": 1001,
      "role": "user",
      "agentName": null,
      "content": "我已经完成了阅读相关文献这一步。",
      "createdAt": "2025-12-08T10:05:00Z"
    },
    {
      "id": 5003,
      "sessionId": 1001,
      "role": "assistant",
      "agentName": "executor",
      "content": "好的，已将步骤「阅读相关文献」标记为已完成。目前还有 2 个步骤未完成。",
      "createdAt": "2025-12-08T10:05:05Z"
    }
  ]
}
```

### 2.3 在会话中发送一条用户消息（触发 Agent）

**POST** `/sessions/:id/messages`

* **说明**：

  * 前端发送一条 user 消息到某个 session（task/global）；
  * 后端：

    * 保存 user 消息
    * 通过 AgentService 调用对应 Agent → LLM → tool calls → DB 更新
    * 保存 assistant 消息
    * 返回 assistant 回复内容和（可选）结构化 `taskPatches`（如果你要在前端可视化 patch 可用）

* **请求体：**

```json
{
  "content": "我今天要做什么？"
}
```

* **成功响应：`200 OK`**

你有两种设计选择：

### 方案 A：只返回最后的 assistant 消息（简单版）

```json
{
  "sessionId": 2001,
  "assistantMessage": {
    "id": 6001,
    "sessionId": 2001,
    "role": "assistant",
    "agentName": "global",
    "content": "今天你的重点任务是：1）完成 AIGC 论文初稿，预计 3 小时；2）整理实验数据，预计 2 小时...",
    "createdAt": "2025-12-08T09:10:00Z"
  }
}
```

前端拿到后：

* 可选择把这条消息直接 append 到本地列表里
* 或者简单地 `invalidateQueries(['sessionMessages', sessionId])` 再重新拉一次列表

---

### 方案 B：附带 taskPatches（如果需要前端感知）

```json
{
  "sessionId": 1001,
  "assistantMessage": {
    "id": 6002,
    "sessionId": 1001,
    "role": "assistant",
    "agentName": "planner",
    "content": "我帮你重新规划了这个任务的步骤和时间安排：...",
    "createdAt": "2025-12-08T11:00:00Z"
  },
  "taskPatches": [
    {
      "kind": "update_step",
      "update_step": {
        "taskId": 1,
        "stepId": 12,
        "fields": {
          "plannedStart": "2025-12-08T14:00:00Z",
          "plannedEnd": "2025-12-08T16:00:00Z"
        }
      }
    }
  ]
}
```

* 第一版前端可以完全忽略 `taskPatches` 字段，只用来 debug；
* 真要用的时候，可以在 UI 里做动画提醒「步骤时间已调整」等。

---

## 3. Global Assistant 相关接口

实际上 GlobalAssistantPage 只用到了两类接口：

1. `GET /sessions/global`（上面已写）
2. `GET /sessions/:id/messages` + `POST /sessions/:id/messages`（上面已写）

没有额外的专用 endpoint。
你可以**约定**：`type="global"` 的 session 中 Agent Router 默认选择 GlobalAgent。

---

## 4. LLM 设置接口（可选，但推荐）

前端 `LLMSettingsPage` 需要一个简单的配置读写接口，以便每个用户设置自己的 base_url、api_key、model。

### 4.1 获取当前用户的 LLM 设置

**GET** `/llm-settings/me`

* **说明**：返回当前用户的 LLM 配置；如果不存在，返回 `null` 或 `404` 取决于你的设计。
  推荐：永远返回 200，body 为 `{ llmSettings: null | {...} }`，方便前端逻辑。

* **成功响应：`200 OK`**

```json
{
  "llmSettings": {
    "baseUrl": "https://api.openai.com",
    "model": "gpt-4.1-mini"
    // 不返回 apiKeyEnc，避免泄露；你可以用一个布尔标记表示“是否已设置过 key”
  }
}
```

或：

```json
{
  "llmSettings": null
}
```

### 4.2 更新当前用户 LLM 设置

**PUT** `/llm-settings/me`

* **说明**：创建或更新当前用户的配置；后端负责加密存储 key。

* **请求体：**

```json
{
  "baseUrl": "https://api.openai.com",
  "apiKey": "sk-xxxxxxx",
  "model": "gpt-4.1-mini"
}
```

> 你可以允许部分字段不传（例如只改 model，不改 baseUrl/key），由后端决定哪个字段更新。

* **成功响应：`200 OK`**

```json
{
  "llmSettings": {
    "baseUrl": "https://api.openai.com",
    "model": "gpt-4.1-mini",
    "hasApiKey": true
  }
}
```

> `hasApiKey` 表示后端已经存了一份 key，但不会返回明文；前端只用它来显示“已设置”。

---

## 5. Task 列表接口（顺手补一下）

前端 TaskListPage 用到：

**GET** `/tasks`

* **可选 query：**

```text
?status=in_progress&limit=50&offset=0
```

* **说明**：

  * `status` 可选，过滤某种状态
  * `limit/offset` 分页，第一版也可以简单返回最近 N 条（不做分页）

* **成功响应：`200 OK`**

```json
{
  "tasks": [
    {
      "id": 1,
      "userId": 123,
      "title": "完成 AIGC 小论文",
      "description": "根据你提供的文本自动生成的任务描述...",
      "status": "in_progress",
      "priority": "high",
      "dueAt": "2025-12-15T23:59:00Z",
      "createdAt": "2025-12-08T10:00:00Z",
      "updatedAt": "2025-12-08T12:30:00Z"
    },
    {
      "id": 2,
      "userId": 123,
      "title": "准备开题报告",
      "description": "",
      "status": "todo",
      "priority": "medium",
      "dueAt": null,
      "createdAt": "2025-12-07T09:00:00Z",
      "updatedAt": "2025-12-07T09:00:00Z"
    }
  ],
  "total": 2
}
```

---

## 6. 总体字段对齐表（方便你检查后端 struct）

| 实体      | 字段名             | 类型      | 说明                                     |
| ------- | --------------- | ------- | -------------------------------------- |
| Task    | id              | number  | 唯一 ID                                  |
|         | userId          | number  | 所属用户 ID                                |
|         | title           | string  | 标题                                     |
|         | description     | string  | 描述                                     |
|         | status          | string  | `todo/in_progress/done/cancelled`      |
|         | priority        | string  | `low/medium/high`                      |
|         | dueAt           | string? | 截止时间                                   |
|         | createdAt       | string  | 创建时间                                   |
|         | updatedAt       | string  | 更新时间                                   |
|         | steps           | Step[]? | 步骤数组（在任务详情中返回）                         |
| Step    | id              | number  | 步骤 ID                                  |
|         | taskId          | number  | 所属任务 ID                                |
|         | orderIndex      | number  | 顺序，从 1 或 0 开始均可                        |
|         | title           | string  | 步骤标题                                   |
|         | detail          | string  | 步骤详情                                   |
|         | status          | string  | `locked/todo/in_progress/done/blocked` |
|         | blockingReason  | string? | 阻塞原因                                   |
|         | estimateMinutes | number? | 预估时长（分钟）                               |
|         | plannedStart    | string? | 计划开始时间                                 |
|         | plannedEnd      | string? | 计划结束时间                                 |
|         | createdAt       | string  |                                        |
|         | updatedAt       | string  |                                        |
| Session | id              | number  | 会话 ID                                  |
|         | userId          | number  | 所属用户 ID                                |
|         | taskId          | number? | 绑定任务 ID 或 null（global）                 |
|         | type            | string  | `task/global`                          |
|         | createdAt       | string  |                                        |
| Message | id              | number  |                                        |
|         | sessionId       | number  | 所属会话 ID                                |
|         | role            | string  | `user/assistant/system`                |
|         | agentName       | string? | `executor/planner/...` 或 null          |
|         | content         | string  | 消息内容                                   |
|         | createdAt       | string  |                                        |

---

如果你后面愿意，我可以再帮你把 **后端 handler 的 JSON 绑定 struct** 写出来，比如 `type CreateTaskFromTextResponse struct { Task TaskDTO; Session SessionDTO }`，以及对应的 `DTO <-> GORM 模型转换` 的样板代码，这样你整个 API 层会非常清晰、稳定。
