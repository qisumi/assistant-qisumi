好，那我直接给你一套**可落地的 Go 后端骨架**：目录结构 + 核心文件示例代码。
你可以 `git init` 之后按这个结构建文件，一边删减 TODO 一边实现细节。

> 说明：
>
> * Web 框架：`gin`
> * DB：`database/sql` + `go-sql-driver/mysql`
> * JWT：`github.com/golang-jwt/jwt/v5`
> * 没有强依赖 sqlx 等，尽量轻量。

---

## 1. 目录结构

```text
.
├── cmd
│   └── server
│       └── main.go
├── internal
│   ├── config
│   │   └── config.go
│   ├── db
│   │   └── db.go
│   ├── auth
│   │   ├── service.go
│   │   └── jwt.go
│   ├── task
│   │   ├── models.go
│   │   ├── repo.go
│   │   └── service.go
│   ├── session
│   │   ├── models.go
│   │   ├── repo.go
│   │   └── service.go
│   ├── llm
│   │   └── client.go
│   ├── agent
│   │   ├── models.go
│   │   ├── router.go
│   │   ├── executor_agent.go
│   │   ├── planner_agent.go
│   │   ├── summarizer_agent.go
│   │   ├── global_agent.go
│   │   └── service.go
│   └── http
│       ├── router.go
│       ├── middleware.go
│       ├── auth_handler.go
│       ├── task_handler.go
│       └── session_handler.go
└── go.mod
```

---

## 2. go.mod 示例

```go
module your-module-name

go 1.22

require (
    github.com/gin-gonic/gin v1.10.0
    github.com/go-sql-driver/mysql v1.8.1
    github.com/golang-jwt/jwt/v5 v5.2.0
)
```

---

## 3. cmd/server/main.go

```go
package main

import (
    "log"

    "your-module-name/internal/config"
    "your-module-name/internal/db"
    "your-module-name/internal/http"
)

func main() {
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("load config: %v", err)
    }

    sqlDB, err := db.NewMySQL(cfg.DatabaseDSN)
    if err != nil {
        log.Fatalf("connect db: %v", err)
    }
    defer sqlDB.Close()

    r := http.NewRouter(cfg, sqlDB)

    if err := r.Run(":" + cfg.HTTPPort); err != nil {
        log.Fatalf("server error: %v", err)
    }
}
```

---

## 4. internal/config/config.go

```go
package config

import (
    "os"
)

type Config struct {
    HTTPPort    string
    DatabaseDSN string
    JWTSecret   string
}

func Load() (*Config, error) {
    cfg := &Config{
        HTTPPort:    getEnv("HTTP_PORT", "8080"),
        DatabaseDSN: getEnv("DATABASE_DSN", "user:pass@tcp(127.0.0.1:3306)/dbname?parseTime=true&charset=utf8mb4"),
        JWTSecret:   getEnv("JWT_SECRET", "dev-secret-change-me"),
    }
    return cfg, nil
}

func getEnv(key, def string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return def
}
```

---

## 5. internal/db/db.go

```go
package db

import (
    "database/sql"
    "time"

    _ "github.com/go-sql-driver/mysql"
)

func NewMySQL(dsn string) (*sql.DB, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    // 资源有限：连接池要小
    db.SetMaxOpenConns(5)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(time.Hour)
    if err := db.Ping(); err != nil {
        return nil, err
    }
    return db, nil
}
```

---

## 6. internal/auth/jwt.go

```go
package auth

import (
    "time"

    "github.com/golang-jwt/jwt/v5"
)

type JWTManager struct {
    Secret []byte
}

func NewJWTManager(secret string) *JWTManager {
    return &JWTManager{Secret: []byte(secret)}
}

func (j *JWTManager) GenerateToken(userID uint64) (string, error) {
    claims := jwt.MapClaims{
        "sub": userID,
        "exp": time.Now().Add(7 * 24 * time.Hour).Unix(),
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(j.Secret)
}

func (j *JWTManager) ParseToken(tokenStr string) (uint64, error) {
    token, err := jwt.Parse(tokenStr, func(t *jwt.Token) (interface{}, error) {
        return j.Secret, nil
    })
    if err != nil || !token.Valid {
        return 0, err
    }
    if claims, ok := token.Claims.(jwt.MapClaims); ok {
        if sub, ok := claims["sub"].(float64); ok {
            return uint64(sub), nil
        }
    }
    return 0, jwt.ErrTokenMalformed
}
```

---

## 7. internal/auth/service.go

```go
package auth

import (
    "context"
    "database/sql"
    "errors"

    "golang.org/x/crypto/bcrypt"
)

type User struct {
    ID           uint64
    Email        string
    DisplayName  string
    PasswordHash string
}

type Service struct {
    db  *sql.DB
    jwt *JWTManager
}

func NewService(db *sql.DB, jwt *JWTManager) *Service {
    return &Service{db: db, jwt: jwt}
}

func (s *Service) Register(ctx context.Context, email, password string) error {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    _, err = s.db.ExecContext(ctx,
        `INSERT INTO users (email, password_hash) VALUES (?, ?)`,
        email, string(hash),
    )
    return err
}

func (s *Service) Login(ctx context.Context, email, password string) (string, error) {
    var u User
    err := s.db.QueryRowContext(ctx,
        `SELECT id, password_hash FROM users WHERE email = ?`, email).
        Scan(&u.ID, &u.PasswordHash)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return "", errors.New("invalid credentials")
        }
        return "", err
    }
    if err := bcrypt.CompareHashAndPassword([]byte(u.PasswordHash), []byte(password)); err != nil {
        return "", errors.New("invalid credentials")
    }
    return s.jwt.GenerateToken(u.ID)
}
```

---

## 8. internal/task/models.go

```go
package task

import "time"

type Task struct {
    ID          uint64     `json:"id"`
    UserID      uint64     `json:"user_id"`
    Title       string     `json:"title"`
    Description string     `json:"description"`
    Status      string     `json:"status"`
    Priority    string     `json:"priority"`
    DueAt       *time.Time `json:"due_at,omitempty"`
    CreatedAt   time.Time  `json:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at"`
    Steps       []Step     `json:"steps,omitempty"`
}

type Step struct {
    ID             uint64     `json:"id"`
    TaskID         uint64     `json:"task_id"`
    OrderIndex     int        `json:"order_index"`
    Title          string     `json:"title"`
    Detail         string     `json:"detail"`
    Status         string     `json:"status"`
    BlockingReason string     `json:"blocking_reason"`
    EstimateMin    *int       `json:"estimate_minutes,omitempty"`
    PlannedStart   *time.Time `json:"planned_start,omitempty"`
    PlannedEnd     *time.Time `json:"planned_end,omitempty"`
    CreatedAt      time.Time  `json:"created_at"`
    UpdatedAt      time.Time  `json:"updated_at"`
}
```

---

## 9. internal/task/repo.go

```go
package task

import (
    "context"
    "database/sql"
)

type Repository struct {
    db *sql.DB
}

func NewRepository(db *sql.DB) *Repository {
    return &Repository{db: db}
}

func (r *Repository) GetTaskWithSteps(ctx context.Context, userID, taskID uint64) (*Task, error) {
    // TODO: 查询 tasks + task_steps
    return nil, nil
}

func (r *Repository) InsertTaskWithSteps(ctx context.Context, t *Task) error {
    // TODO: 事务插入 task & steps
    return nil
}

func (r *Repository) ListTasks(ctx context.Context, userID uint64) ([]Task, error) {
    // TODO: 简单列表
    return nil, nil
}
```

---

## 10. internal/task/service.go

```go
package task

import (
    "context"

    "your-module-name/internal/llm"
)

type Service struct {
    repo      *Repository
    llmClient llm.Client
}

func NewService(repo *Repository, llmClient llm.Client) *Service {
    return &Service{repo: repo, llmClient: llmClient}
}

// CreateFromText: 调用 LLM 把一段文本变成 Task + Steps
func (s *Service) CreateFromText(ctx context.Context, userID uint64, rawText string, cfg llm.Config) (*Task, error) {
    // 1. 构造 prompt 和 ChatRequest（调用 TaskCreation / Planner Agent）
    // 2. 调用 llmClient.Chat
    // 3. 解析 JSON -> Task + Steps
    // 4. repo.InsertTaskWithSteps
    // 5. 返回 Task
    return nil, nil
}
```

---

## 11. internal/session/models.go

```go
package session

import "time"

type Session struct {
    ID        uint64    `json:"id"`
    UserID    uint64    `json:"user_id"`
    TaskID    *uint64   `json:"task_id,omitempty"`
    Type      string    `json:"type"` // "task" or "global"
    CreatedAt time.Time `json:"created_at"`
}

type Message struct {
    ID        uint64    `json:"id"`
    SessionID uint64    `json:"session_id"`
    Role      string    `json:"role"` // "user" | "assistant" | "system"
    AgentName *string   `json:"agent_name,omitempty"`
    Content   string    `json:"content"`
    CreatedAt time.Time `json:"created_at"`
}
```

---

## 12. internal/session/repo.go

```go
package session

import (
    "context"
    "database/sql"
)

type Repository struct {
    db *sql.DB
}

func NewRepository(db *sql.DB) *Repository {
    return &Repository{db: db}
}

func (r *Repository) GetSession(ctx context.Context, sessionID uint64) (*Session, error) {
    // TODO: 查询 sessions
    return nil, nil
}

func (r *Repository) CreateMessage(ctx context.Context, m *Message) error {
    // TODO: 插入 messages
    return nil
}

func (r *Repository) ListRecentMessages(ctx context.Context, sessionID uint64, limit int) ([]Message, error) {
    // TODO: 按 created_at DESC LIMIT
    return nil, nil
}
```

---

## 13. internal/llm/client.go

```go
package llm

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
)

type Config struct {
    BaseURL string
    APIKey  string
    Model   string
}

type Message struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

type ChatRequest struct {
    Model    string    `json:"model"`
    Messages []Message `json:"messages"`
    // TODO: tools/tool_choice 等
}

type ChatResponse struct {
    // TODO: 按你的 LLM 服务响应结构定义
}

type Client interface {
    Chat(ctx context.Context, cfg Config, req ChatRequest) (*ChatResponse, error)
}

type HTTPClient struct {
    httpClient *http.Client
}

func NewHTTPClient() *HTTPClient {
    return &HTTPClient{httpClient: &http.Client{}}
}

func (c *HTTPClient) Chat(ctx context.Context, cfg Config, req ChatRequest) (*ChatResponse, error) {
    body, err := json.Marshal(req)
    if err != nil {
        return nil, err
    }
    url := fmt.Sprintf("%s/v1/chat/completions", cfg.BaseURL)
    httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(body))
    if err != nil {
        return nil, err
    }
    httpReq.Header.Set("Authorization", "Bearer "+cfg.APIKey)
    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode >= 300 {
        return nil, fmt.Errorf("llm http %d", resp.StatusCode)
    }

    var cr ChatResponse
    if err := json.NewDecoder(resp.Body).Decode(&cr); err != nil {
        return nil, err
    }
    return &cr, nil
}
```

---

## 14. internal/agent/models.go

```go
package agent

import (
    "time"

    "your-module-name/internal/llm"
    "your-module-name/internal/session"
    "your-module-name/internal/task"
)

type AgentRequest struct {
    UserID    uint64
    Session   *session.Session
    Task      *task.Task
    Messages  []session.Message
    UserInput string
    Now       time.Time
    LLMConfig llm.Config
}

type TaskPatch struct {
    Type    string                 `json:"type"`
    Payload map[string]interface{} `json:"payload"`
}

type AgentResponse struct {
    AssistantMessage string      `json:"assistant_message"`
    TaskPatches      []TaskPatch `json:"task_patches"`
}

type Agent interface {
    Name() string
    Handle(req AgentRequest) (*AgentResponse, error)
}
```

---

## 15. internal/agent/router.go（Router Agent 骨架）

```go
package agent

import (
    "strings"
)

type Router interface {
    Route(req AgentRequest) string
}

type SimpleRouter struct{}

func NewSimpleRouter() *SimpleRouter {
    return &SimpleRouter{}
}

func (r *SimpleRouter) Route(req AgentRequest) string {
    text := strings.ToLower(req.UserInput)

    if req.Session.Type == "global" {
        return "global"
    }

    if strings.Contains(text, "总结") || strings.Contains(text, "overview") {
        return "summarizer"
    }
    if strings.Contains(text, "重排") || strings.Contains(text, "reschedule") || strings.Contains(text, "重新规划") {
        return "planner"
    }
    // 默认执行器
    return "executor"
}
```

---

## 16. internal/agent/executor_agent.go（示意）

```go
package agent

import (
    "your-module-name/internal/llm"
)

type ExecutorAgent struct {
    llmClient llm.Client
}

func NewExecutorAgent(llmClient llm.Client) *ExecutorAgent {
    return &ExecutorAgent{llmClient: llmClient}
}

func (a *ExecutorAgent) Name() string { return "executor" }

func (a *ExecutorAgent) Handle(req AgentRequest) (*AgentResponse, error) {
    // TODO: 构造 messages + tools 调用 LLM，得到：
    // - assistant 回复文本
    // - 对任务的结构化 patch（例如某个步骤 status=done）
    return &AgentResponse{
        AssistantMessage: "TODO: executor agent reply",
        TaskPatches:      nil,
    }, nil
}
```

其他 `PlannerAgent / SummarizerAgent / GlobalAgent` 类似。

---

## 17. internal/agent/service.go（多 Agent 调用入口）

```go
package agent

import (
    "context"
    "database/sql"
    "time"

    "your-module-name/internal/llm"
    "your-module-name/internal/session"
    "your-module-name/internal/task"
)

type Service struct {
    router      Router
    agents      map[string]Agent
    taskRepo    *task.Repository
    sessionRepo *session.Repository
    db          *sql.DB
}

func NewService(
    router Router,
    agents []Agent,
    taskRepo *task.Repository,
    sessionRepo *session.Repository,
    db *sql.DB,
) *Service {
    m := make(map[string]Agent)
    for _, ag := range agents {
        m[ag.Name()] = ag
    }
    return &Service{
        router:      router,
        agents:      m,
        taskRepo:    taskRepo,
        sessionRepo: sessionRepo,
        db:          db,
    }
}

func (s *Service) HandleUserMessage(
    ctx context.Context,
    userID, sessionID uint64,
    userInput string,
    cfg llm.Config,
) (*AgentResponse, error) {

    sess, err := s.sessionRepo.GetSession(ctx, sessionID)
    if err != nil {
        return nil, err
    }
    msgs, err := s.sessionRepo.ListRecentMessages(ctx, sessionID, 20)
    if err != nil {
        return nil, err
    }

    var t *task.Task
    if sess.TaskID != nil {
        t, err = s.taskRepo.GetTaskWithSteps(ctx, userID, *sess.TaskID)
        if err != nil {
            return nil, err
        }
    }

    req := AgentRequest{
        UserID:    userID,
        Session:   sess,
        Task:      t,
        Messages:  msgs,
        UserInput: userInput,
        Now:       time.Now(),
        LLMConfig: cfg,
    }

    agentName := s.router.Route(req)
    ag, ok := s.agents[agentName]
    if !ok {
        // fallback
        ag = s.agents["executor"]
    }

    resp, err := ag.Handle(req)
    if err != nil {
        return nil, err
    }

    // TODO: 开启事务: 应用 TaskPatches 更新 task & steps & dependencies

    // TODO: 写 assistant 消息: role=assistant, agent_name=ag.Name()

    return resp, nil
}
```

---

## 18. internal/http/middleware.go（认证中间件）

```go
package http

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "your-module-name/internal/auth"
)

func AuthMiddleware(jwtMgr *auth.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing Authorization header"})
            return
        }
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid Authorization header"})
            return
        }
        userID, err := jwtMgr.ParseToken(parts[1])
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
            return
        }
        c.Set("userID", userID)
        c.Next()
    }
}

func GetUserID(c *gin.Context) uint64 {
    if v, ok := c.Get("userID"); ok {
        if id, ok := v.(uint64); ok {
            return id
        }
    }
    return 0
}
```

---

## 19. internal/http/auth_handler.go

```go
package http

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "your-module-name/internal/auth"
)

type AuthHandler struct {
    svc *auth.Service
}

func NewAuthHandler(svc *auth.Service) *AuthHandler {
    return &AuthHandler{svc: svc}
}

func (h *AuthHandler) RegisterRoutes(rg *gin.RouterGroup) {
    rg.POST("/register", h.register)
    rg.POST("/login", h.login)
}

type registerReq struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
}

func (h *AuthHandler) register(c *gin.Context) {
    var req registerReq
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    if err := h.svc.Register(c, req.Email, req.Password); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    c.Status(http.StatusCreated)
}

type loginReq struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}

func (h *AuthHandler) login(c *gin.Context) {
    var req loginReq
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    token, err := h.svc.Login(c, req.Email, req.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"token": token})
}
```

---

## 20. internal/http/task_handler.go（包含“从文本创建任务”）

```go
package http

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "your-module-name/internal/llm"
    "your-module-name/internal/task"
)

type TaskHandler struct {
    taskSvc *task.Service
    // TODO: 注入 user_llm_settings service，用来查当前用户的 LLMConfig
}

func NewTaskHandler(taskSvc *task.Service) *TaskHandler {
    return &TaskHandler{taskSvc: taskSvc}
}

func (h *TaskHandler) RegisterRoutes(rg *gin.RouterGroup) {
    rg.POST("/tasks/from-text", h.createFromText)
    // TODO: tasks 列表 / 详情 / patch
}

type createFromTextReq struct {
    RawText string `json:"raw_text" binding:"required"`
}

func (h *TaskHandler) createFromText(c *gin.Context) {
    userID := GetUserID(c)
    var req createFromTextReq
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // TODO: 从 DB 根据 userID 查 LLMConfig（示例这里先硬编码）
    cfg := llm.Config{
        BaseURL: "https://api.openai.com",
        APIKey:  "TODO",
        Model:   "gpt-4.1-mini",
    }

    t, err := h.taskSvc.CreateFromText(c, userID, req.RawText, cfg)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"task": t})
}
```

---

## 21. internal/http/session_handler.go（任务会话发消息 → Agent）

```go
package http

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "your-module-name/internal/agent"
    "your-module-name/internal/llm"
)

type SessionHandler struct {
    agentSvc *agent.Service
    // TODO: 注入 user_llm_settings service，获取 LLMConfig
}

func NewSessionHandler(agentSvc *agent.Service) *SessionHandler {
    return &SessionHandler{agentSvc: agentSvc}
}

func (h *SessionHandler) RegisterRoutes(rg *gin.RouterGroup) {
    rg.POST("/sessions/:id/messages", h.postMessage)
}

type postMessageReq struct {
    Content string `json:"content" binding:"required"`
}

func (h *SessionHandler) postMessage(c *gin.Context) {
    userID := GetUserID(c)
    sidStr := c.Param("id")
    sid, err := strconv.ParseUint(sidStr, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid session id"})
        return
    }

    var req postMessageReq
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // TODO: 从 DB 根据 userID 获取 LLMConfig
    cfg := llm.Config{
        BaseURL: "https://api.openai.com",
        APIKey:  "TODO",
        Model:   "gpt-4.1-mini",
    }

    resp, err := h.agentSvc.HandleUserMessage(c, userID, sid, req.Content, cfg)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{
        "assistant_message": resp.AssistantMessage,
        "task_patches":      resp.TaskPatches,
    })
}
```

---

## 22. internal/http/router.go

```go
package http

import (
    "database/sql"

    "github.com/gin-gonic/gin"
    "your-module-name/internal/agent"
    "your-module-name/internal/auth"
    "your-module-name/internal/config"
    "your-module-name/internal/llm"
    "your-module-name/internal/session"
    "your-module-name/internal/task"
)

func NewRouter(cfg *config.Config, db *sql.DB) *gin.Engine {
    r := gin.Default()

    jwtMgr := auth.NewJWTManager(cfg.JWTSecret)
    authSvc := auth.NewService(db, jwtMgr)

    taskRepo := task.NewRepository(db)
    llmClient := llm.NewHTTPClient()
    taskSvc := task.NewService(taskRepo, llmClient)

    sessionRepo := session.NewRepository(db)

    // Agents
    router := agent.NewSimpleRouter()
    executorAgent := agent.NewExecutorAgent(llmClient)
    // TODO: planner, summarizer, global 也初始化
    agents := []agent.Agent{executorAgent}
    agentSvc := agent.NewService(router, agents, taskRepo, sessionRepo, db)

    // Handlers
    authHandler := NewAuthHandler(authSvc)
    taskHandler := NewTaskHandler(taskSvc)
    sessionHandler := NewSessionHandler(agentSvc)

    api := r.Group("/api")

    authHandler.RegisterRoutes(api.Group("/auth"))

    // 需要登录的路由
    authGroup := api.Group("")
    authGroup.Use(AuthMiddleware(jwtMgr))

    taskHandler.RegisterRoutes(authGroup)
    sessionHandler.RegisterRoutes(authGroup)

    return r
}
```